// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        (unknown)
// source: injective/exchange/v1beta1/exchange.proto

package types

import (
	types1 "github.com/InjectiveLabs/injective-core/injective-chain/modules/oracle/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AtomicMarketOrderAccessLevel int32

const (
	AtomicMarketOrderAccessLevel_Nobody AtomicMarketOrderAccessLevel = 0
	// currently unsupported
	AtomicMarketOrderAccessLevel_BeginBlockerSmartContractsOnly AtomicMarketOrderAccessLevel = 1
	AtomicMarketOrderAccessLevel_SmartContractsOnly             AtomicMarketOrderAccessLevel = 2
	AtomicMarketOrderAccessLevel_Everyone                       AtomicMarketOrderAccessLevel = 3
)

// Enum value maps for AtomicMarketOrderAccessLevel.
var (
	AtomicMarketOrderAccessLevel_name = map[int32]string{
		0: "Nobody",
		1: "BeginBlockerSmartContractsOnly",
		2: "SmartContractsOnly",
		3: "Everyone",
	}
	AtomicMarketOrderAccessLevel_value = map[string]int32{
		"Nobody":                         0,
		"BeginBlockerSmartContractsOnly": 1,
		"SmartContractsOnly":             2,
		"Everyone":                       3,
	}
)

func (x AtomicMarketOrderAccessLevel) Enum() *AtomicMarketOrderAccessLevel {
	p := new(AtomicMarketOrderAccessLevel)
	*p = x
	return p
}

func (x AtomicMarketOrderAccessLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AtomicMarketOrderAccessLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v1beta1_exchange_proto_enumTypes[0].Descriptor()
}

func (AtomicMarketOrderAccessLevel) Type() protoreflect.EnumType {
	return &file_injective_exchange_v1beta1_exchange_proto_enumTypes[0]
}

func (x AtomicMarketOrderAccessLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AtomicMarketOrderAccessLevel.Descriptor instead.
func (AtomicMarketOrderAccessLevel) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{0}
}

type MarketStatus int32

const (
	MarketStatus_Unspecified MarketStatus = 0
	MarketStatus_Active      MarketStatus = 1
	MarketStatus_Paused      MarketStatus = 2
	MarketStatus_Demolished  MarketStatus = 3
	MarketStatus_Expired     MarketStatus = 4
)

// Enum value maps for MarketStatus.
var (
	MarketStatus_name = map[int32]string{
		0: "Unspecified",
		1: "Active",
		2: "Paused",
		3: "Demolished",
		4: "Expired",
	}
	MarketStatus_value = map[string]int32{
		"Unspecified": 0,
		"Active":      1,
		"Paused":      2,
		"Demolished":  3,
		"Expired":     4,
	}
)

func (x MarketStatus) Enum() *MarketStatus {
	p := new(MarketStatus)
	*p = x
	return p
}

func (x MarketStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MarketStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v1beta1_exchange_proto_enumTypes[1].Descriptor()
}

func (MarketStatus) Type() protoreflect.EnumType {
	return &file_injective_exchange_v1beta1_exchange_proto_enumTypes[1]
}

func (x MarketStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MarketStatus.Descriptor instead.
func (MarketStatus) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{1}
}

type OrderType int32

const (
	OrderType_UNSPECIFIED OrderType = 0
	OrderType_BUY         OrderType = 1
	OrderType_SELL        OrderType = 2
	OrderType_STOP_BUY    OrderType = 3
	OrderType_STOP_SELL   OrderType = 4
	OrderType_TAKE_BUY    OrderType = 5
	OrderType_TAKE_SELL   OrderType = 6
	OrderType_BUY_PO      OrderType = 7
	OrderType_SELL_PO     OrderType = 8
	OrderType_BUY_ATOMIC  OrderType = 9
	OrderType_SELL_ATOMIC OrderType = 10
)

// Enum value maps for OrderType.
var (
	OrderType_name = map[int32]string{
		0:  "UNSPECIFIED",
		1:  "BUY",
		2:  "SELL",
		3:  "STOP_BUY",
		4:  "STOP_SELL",
		5:  "TAKE_BUY",
		6:  "TAKE_SELL",
		7:  "BUY_PO",
		8:  "SELL_PO",
		9:  "BUY_ATOMIC",
		10: "SELL_ATOMIC",
	}
	OrderType_value = map[string]int32{
		"UNSPECIFIED": 0,
		"BUY":         1,
		"SELL":        2,
		"STOP_BUY":    3,
		"STOP_SELL":   4,
		"TAKE_BUY":    5,
		"TAKE_SELL":   6,
		"BUY_PO":      7,
		"SELL_PO":     8,
		"BUY_ATOMIC":  9,
		"SELL_ATOMIC": 10,
	}
)

func (x OrderType) Enum() *OrderType {
	p := new(OrderType)
	*p = x
	return p
}

func (x OrderType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderType) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v1beta1_exchange_proto_enumTypes[2].Descriptor()
}

func (OrderType) Type() protoreflect.EnumType {
	return &file_injective_exchange_v1beta1_exchange_proto_enumTypes[2]
}

func (x OrderType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderType.Descriptor instead.
func (OrderType) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{2}
}

type ExecutionType int32

const (
	ExecutionType_UnspecifiedExecutionType ExecutionType = 0
	ExecutionType_Market                   ExecutionType = 1
	ExecutionType_LimitFill                ExecutionType = 2
	ExecutionType_LimitMatchRestingOrder   ExecutionType = 3
	ExecutionType_LimitMatchNewOrder       ExecutionType = 4
	ExecutionType_MarketLiquidation        ExecutionType = 5
	ExecutionType_ExpiryMarketSettlement   ExecutionType = 6
)

// Enum value maps for ExecutionType.
var (
	ExecutionType_name = map[int32]string{
		0: "UnspecifiedExecutionType",
		1: "Market",
		2: "LimitFill",
		3: "LimitMatchRestingOrder",
		4: "LimitMatchNewOrder",
		5: "MarketLiquidation",
		6: "ExpiryMarketSettlement",
	}
	ExecutionType_value = map[string]int32{
		"UnspecifiedExecutionType": 0,
		"Market":                   1,
		"LimitFill":                2,
		"LimitMatchRestingOrder":   3,
		"LimitMatchNewOrder":       4,
		"MarketLiquidation":        5,
		"ExpiryMarketSettlement":   6,
	}
)

func (x ExecutionType) Enum() *ExecutionType {
	p := new(ExecutionType)
	*p = x
	return p
}

func (x ExecutionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ExecutionType) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v1beta1_exchange_proto_enumTypes[3].Descriptor()
}

func (ExecutionType) Type() protoreflect.EnumType {
	return &file_injective_exchange_v1beta1_exchange_proto_enumTypes[3]
}

func (x ExecutionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ExecutionType.Descriptor instead.
func (ExecutionType) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{3}
}

type OrderMask int32

const (
	OrderMask_UNUSED                  OrderMask = 0
	OrderMask_ANY                     OrderMask = 1
	OrderMask_REGULAR                 OrderMask = 2
	OrderMask_CONDITIONAL             OrderMask = 4
	OrderMask_DIRECTION_BUY_OR_HIGHER OrderMask = 8  // for conditional orders means HIGHER
	OrderMask_DIRECTION_SELL_OR_LOWER OrderMask = 16 // for conditional orders means LOWER
	OrderMask_TYPE_MARKET             OrderMask = 32
	OrderMask_TYPE_LIMIT              OrderMask = 64
)

// Enum value maps for OrderMask.
var (
	OrderMask_name = map[int32]string{
		0:  "UNUSED",
		1:  "ANY",
		2:  "REGULAR",
		4:  "CONDITIONAL",
		8:  "DIRECTION_BUY_OR_HIGHER",
		16: "DIRECTION_SELL_OR_LOWER",
		32: "TYPE_MARKET",
		64: "TYPE_LIMIT",
	}
	OrderMask_value = map[string]int32{
		"UNUSED":                  0,
		"ANY":                     1,
		"REGULAR":                 2,
		"CONDITIONAL":             4,
		"DIRECTION_BUY_OR_HIGHER": 8,
		"DIRECTION_SELL_OR_LOWER": 16,
		"TYPE_MARKET":             32,
		"TYPE_LIMIT":              64,
	}
)

func (x OrderMask) Enum() *OrderMask {
	p := new(OrderMask)
	*p = x
	return p
}

func (x OrderMask) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderMask) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v1beta1_exchange_proto_enumTypes[4].Descriptor()
}

func (OrderMask) Type() protoreflect.EnumType {
	return &file_injective_exchange_v1beta1_exchange_proto_enumTypes[4]
}

func (x OrderMask) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderMask.Descriptor instead.
func (OrderMask) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{4}
}

type Params struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// spot_market_instant_listing_fee defines the expedited fee in INJ required
	// to create a spot market by bypassing governance
	SpotMarketInstantListingFee *types.Coin `protobuf:"bytes,1,opt,name=spot_market_instant_listing_fee,json=spotMarketInstantListingFee,proto3" json:"spot_market_instant_listing_fee,omitempty"`
	// derivative_market_instant_listing_fee defines the expedited fee in INJ
	// required to create a derivative market by bypassing governance
	DerivativeMarketInstantListingFee *types.Coin `protobuf:"bytes,2,opt,name=derivative_market_instant_listing_fee,json=derivativeMarketInstantListingFee,proto3" json:"derivative_market_instant_listing_fee,omitempty"`
	// default_spot_maker_fee defines the default exchange trade fee for makers on
	// a spot market
	DefaultSpotMakerFeeRate string `protobuf:"bytes,3,opt,name=default_spot_maker_fee_rate,json=defaultSpotMakerFeeRate,proto3" json:"default_spot_maker_fee_rate,omitempty"`
	// default_spot_taker_fee_rate defines the default exchange trade fee rate for
	// takers on a new spot market
	DefaultSpotTakerFeeRate string `protobuf:"bytes,4,opt,name=default_spot_taker_fee_rate,json=defaultSpotTakerFeeRate,proto3" json:"default_spot_taker_fee_rate,omitempty"`
	// default_derivative_maker_fee defines the default exchange trade fee for
	// makers on a new derivative market
	DefaultDerivativeMakerFeeRate string `protobuf:"bytes,5,opt,name=default_derivative_maker_fee_rate,json=defaultDerivativeMakerFeeRate,proto3" json:"default_derivative_maker_fee_rate,omitempty"`
	// default_derivative_taker_fee defines the default exchange trade fee for
	// takers on a new derivative market
	DefaultDerivativeTakerFeeRate string `protobuf:"bytes,6,opt,name=default_derivative_taker_fee_rate,json=defaultDerivativeTakerFeeRate,proto3" json:"default_derivative_taker_fee_rate,omitempty"`
	// default_initial_margin_ratio defines the default initial margin ratio on a
	// new derivative market
	DefaultInitialMarginRatio string `protobuf:"bytes,7,opt,name=default_initial_margin_ratio,json=defaultInitialMarginRatio,proto3" json:"default_initial_margin_ratio,omitempty"`
	// default_maintenance_margin_ratio defines the default maintenance margin
	// ratio on a new derivative market
	DefaultMaintenanceMarginRatio string `protobuf:"bytes,8,opt,name=default_maintenance_margin_ratio,json=defaultMaintenanceMarginRatio,proto3" json:"default_maintenance_margin_ratio,omitempty"`
	// default_funding_interval defines the default funding interval on a
	// derivative market
	DefaultFundingInterval int64 `protobuf:"varint,9,opt,name=default_funding_interval,json=defaultFundingInterval,proto3" json:"default_funding_interval,omitempty"`
	// funding_multiple defines the timestamp multiple that the funding timestamp
	// should be a multiple of
	FundingMultiple int64 `protobuf:"varint,10,opt,name=funding_multiple,json=fundingMultiple,proto3" json:"funding_multiple,omitempty"`
	// relayer_fee_share_rate defines the trade fee share percentage that goes to
	// relayers
	RelayerFeeShareRate string `protobuf:"bytes,11,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3" json:"relayer_fee_share_rate,omitempty"`
	// default_hourly_funding_rate_cap defines the default maximum absolute value
	// of the hourly funding rate
	DefaultHourlyFundingRateCap string `protobuf:"bytes,12,opt,name=default_hourly_funding_rate_cap,json=defaultHourlyFundingRateCap,proto3" json:"default_hourly_funding_rate_cap,omitempty"`
	// hourly_interest_rate defines the hourly interest rate
	DefaultHourlyInterestRate string `protobuf:"bytes,13,opt,name=default_hourly_interest_rate,json=defaultHourlyInterestRate,proto3" json:"default_hourly_interest_rate,omitempty"`
	// max_derivative_order_side_count defines the maximum number of derivative
	// active orders a subaccount can have for a given orderbook side
	MaxDerivativeOrderSideCount uint32 `protobuf:"varint,14,opt,name=max_derivative_order_side_count,json=maxDerivativeOrderSideCount,proto3" json:"max_derivative_order_side_count,omitempty"`
	// inj_reward_staked_requirement_threshold defines the threshold on INJ
	// rewards after which one also needs staked INJ to receive more
	InjRewardStakedRequirementThreshold string `protobuf:"bytes,15,opt,name=inj_reward_staked_requirement_threshold,json=injRewardStakedRequirementThreshold,proto3" json:"inj_reward_staked_requirement_threshold,omitempty"`
	// the trading_rewards_vesting_duration defines the vesting times for trading
	// rewards
	TradingRewardsVestingDuration int64 `protobuf:"varint,16,opt,name=trading_rewards_vesting_duration,json=tradingRewardsVestingDuration,proto3" json:"trading_rewards_vesting_duration,omitempty"`
	// liquidator_reward_share_rate defines the ratio of the split of the surplus
	// collateral that goes to the liquidator
	LiquidatorRewardShareRate string `protobuf:"bytes,17,opt,name=liquidator_reward_share_rate,json=liquidatorRewardShareRate,proto3" json:"liquidator_reward_share_rate,omitempty"`
	// binary_options_market_instant_listing_fee defines the expedited fee in INJ
	// required to create a derivative market by bypassing governance
	BinaryOptionsMarketInstantListingFee *types.Coin `protobuf:"bytes,18,opt,name=binary_options_market_instant_listing_fee,json=binaryOptionsMarketInstantListingFee,proto3" json:"binary_options_market_instant_listing_fee,omitempty"`
	// atomic_market_order_access_level defines the required access permissions
	// for executing atomic market orders
	AtomicMarketOrderAccessLevel AtomicMarketOrderAccessLevel `protobuf:"varint,19,opt,name=atomic_market_order_access_level,json=atomicMarketOrderAccessLevel,proto3,enum=injective.exchange.v1beta1.AtomicMarketOrderAccessLevel" json:"atomic_market_order_access_level,omitempty"`
	// spot_atomic_market_order_fee_multiplier defines the default multiplier for
	// executing atomic market orders in spot markets
	SpotAtomicMarketOrderFeeMultiplier string `protobuf:"bytes,20,opt,name=spot_atomic_market_order_fee_multiplier,json=spotAtomicMarketOrderFeeMultiplier,proto3" json:"spot_atomic_market_order_fee_multiplier,omitempty"`
	// derivative_atomic_market_order_fee_multiplier defines the default
	// multiplier for executing atomic market orders in derivative markets
	DerivativeAtomicMarketOrderFeeMultiplier string `protobuf:"bytes,21,opt,name=derivative_atomic_market_order_fee_multiplier,json=derivativeAtomicMarketOrderFeeMultiplier,proto3" json:"derivative_atomic_market_order_fee_multiplier,omitempty"`
	// binary_options_atomic_market_order_fee_multiplier defines the default
	// multiplier for executing atomic market orders in binary markets
	BinaryOptionsAtomicMarketOrderFeeMultiplier string `protobuf:"bytes,22,opt,name=binary_options_atomic_market_order_fee_multiplier,json=binaryOptionsAtomicMarketOrderFeeMultiplier,proto3" json:"binary_options_atomic_market_order_fee_multiplier,omitempty"`
	// minimal_protocol_fee_rate defines the minimal protocol fee rate
	MinimalProtocolFeeRate string `protobuf:"bytes,23,opt,name=minimal_protocol_fee_rate,json=minimalProtocolFeeRate,proto3" json:"minimal_protocol_fee_rate,omitempty"`
	// is_instant_derivative_market_launch_enabled defines whether instant
	// derivative market launch is enabled
	IsInstantDerivativeMarketLaunchEnabled bool  `protobuf:"varint,24,opt,name=is_instant_derivative_market_launch_enabled,json=isInstantDerivativeMarketLaunchEnabled,proto3" json:"is_instant_derivative_market_launch_enabled,omitempty"`
	PostOnlyModeHeightThreshold            int64 `protobuf:"varint,25,opt,name=post_only_mode_height_threshold,json=postOnlyModeHeightThreshold,proto3" json:"post_only_mode_height_threshold,omitempty"`
	// Maximum time in seconds since the last mark price update to allow a
	// decrease in margin
	MarginDecreasePriceTimestampThresholdSeconds int64 `protobuf:"varint,26,opt,name=margin_decrease_price_timestamp_threshold_seconds,json=marginDecreasePriceTimestampThresholdSeconds,proto3" json:"margin_decrease_price_timestamp_threshold_seconds,omitempty"`
	// List of addresses that are allowed to perform exchange admin operations
	ExchangeAdmins []string `protobuf:"bytes,27,rep,name=exchange_admins,json=exchangeAdmins,proto3" json:"exchange_admins,omitempty"`
	// inj_auction_max_cap defines the maximum cap for INJ sent to auction
	InjAuctionMaxCap string `protobuf:"bytes,28,opt,name=inj_auction_max_cap,json=injAuctionMaxCap,proto3" json:"inj_auction_max_cap,omitempty"`
	// fixed_gas_enabled indicates if msg server will consume fixed gas amount for
	// certain msg types
	FixedGasEnabled bool `protobuf:"varint,29,opt,name=fixed_gas_enabled,json=fixedGasEnabled,proto3" json:"fixed_gas_enabled,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Params) Reset() {
	*x = Params{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Params) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Params) ProtoMessage() {}

func (x *Params) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Params.ProtoReflect.Descriptor instead.
func (*Params) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{0}
}

func (x *Params) GetSpotMarketInstantListingFee() *types.Coin {
	if x != nil {
		return x.SpotMarketInstantListingFee
	}
	return nil
}

func (x *Params) GetDerivativeMarketInstantListingFee() *types.Coin {
	if x != nil {
		return x.DerivativeMarketInstantListingFee
	}
	return nil
}

func (x *Params) GetDefaultSpotMakerFeeRate() string {
	if x != nil {
		return x.DefaultSpotMakerFeeRate
	}
	return ""
}

func (x *Params) GetDefaultSpotTakerFeeRate() string {
	if x != nil {
		return x.DefaultSpotTakerFeeRate
	}
	return ""
}

func (x *Params) GetDefaultDerivativeMakerFeeRate() string {
	if x != nil {
		return x.DefaultDerivativeMakerFeeRate
	}
	return ""
}

func (x *Params) GetDefaultDerivativeTakerFeeRate() string {
	if x != nil {
		return x.DefaultDerivativeTakerFeeRate
	}
	return ""
}

func (x *Params) GetDefaultInitialMarginRatio() string {
	if x != nil {
		return x.DefaultInitialMarginRatio
	}
	return ""
}

func (x *Params) GetDefaultMaintenanceMarginRatio() string {
	if x != nil {
		return x.DefaultMaintenanceMarginRatio
	}
	return ""
}

func (x *Params) GetDefaultFundingInterval() int64 {
	if x != nil {
		return x.DefaultFundingInterval
	}
	return 0
}

func (x *Params) GetFundingMultiple() int64 {
	if x != nil {
		return x.FundingMultiple
	}
	return 0
}

func (x *Params) GetRelayerFeeShareRate() string {
	if x != nil {
		return x.RelayerFeeShareRate
	}
	return ""
}

func (x *Params) GetDefaultHourlyFundingRateCap() string {
	if x != nil {
		return x.DefaultHourlyFundingRateCap
	}
	return ""
}

func (x *Params) GetDefaultHourlyInterestRate() string {
	if x != nil {
		return x.DefaultHourlyInterestRate
	}
	return ""
}

func (x *Params) GetMaxDerivativeOrderSideCount() uint32 {
	if x != nil {
		return x.MaxDerivativeOrderSideCount
	}
	return 0
}

func (x *Params) GetInjRewardStakedRequirementThreshold() string {
	if x != nil {
		return x.InjRewardStakedRequirementThreshold
	}
	return ""
}

func (x *Params) GetTradingRewardsVestingDuration() int64 {
	if x != nil {
		return x.TradingRewardsVestingDuration
	}
	return 0
}

func (x *Params) GetLiquidatorRewardShareRate() string {
	if x != nil {
		return x.LiquidatorRewardShareRate
	}
	return ""
}

func (x *Params) GetBinaryOptionsMarketInstantListingFee() *types.Coin {
	if x != nil {
		return x.BinaryOptionsMarketInstantListingFee
	}
	return nil
}

func (x *Params) GetAtomicMarketOrderAccessLevel() AtomicMarketOrderAccessLevel {
	if x != nil {
		return x.AtomicMarketOrderAccessLevel
	}
	return AtomicMarketOrderAccessLevel_Nobody
}

func (x *Params) GetSpotAtomicMarketOrderFeeMultiplier() string {
	if x != nil {
		return x.SpotAtomicMarketOrderFeeMultiplier
	}
	return ""
}

func (x *Params) GetDerivativeAtomicMarketOrderFeeMultiplier() string {
	if x != nil {
		return x.DerivativeAtomicMarketOrderFeeMultiplier
	}
	return ""
}

func (x *Params) GetBinaryOptionsAtomicMarketOrderFeeMultiplier() string {
	if x != nil {
		return x.BinaryOptionsAtomicMarketOrderFeeMultiplier
	}
	return ""
}

func (x *Params) GetMinimalProtocolFeeRate() string {
	if x != nil {
		return x.MinimalProtocolFeeRate
	}
	return ""
}

func (x *Params) GetIsInstantDerivativeMarketLaunchEnabled() bool {
	if x != nil {
		return x.IsInstantDerivativeMarketLaunchEnabled
	}
	return false
}

func (x *Params) GetPostOnlyModeHeightThreshold() int64 {
	if x != nil {
		return x.PostOnlyModeHeightThreshold
	}
	return 0
}

func (x *Params) GetMarginDecreasePriceTimestampThresholdSeconds() int64 {
	if x != nil {
		return x.MarginDecreasePriceTimestampThresholdSeconds
	}
	return 0
}

func (x *Params) GetExchangeAdmins() []string {
	if x != nil {
		return x.ExchangeAdmins
	}
	return nil
}

func (x *Params) GetInjAuctionMaxCap() string {
	if x != nil {
		return x.InjAuctionMaxCap
	}
	return ""
}

func (x *Params) GetFixedGasEnabled() bool {
	if x != nil {
		return x.FixedGasEnabled
	}
	return false
}

type MarketFeeMultiplier struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MarketId      string                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	FeeMultiplier string                 `protobuf:"bytes,2,opt,name=fee_multiplier,json=feeMultiplier,proto3" json:"fee_multiplier,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketFeeMultiplier) Reset() {
	*x = MarketFeeMultiplier{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketFeeMultiplier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketFeeMultiplier) ProtoMessage() {}

func (x *MarketFeeMultiplier) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketFeeMultiplier.ProtoReflect.Descriptor instead.
func (*MarketFeeMultiplier) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{1}
}

func (x *MarketFeeMultiplier) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *MarketFeeMultiplier) GetFeeMultiplier() string {
	if x != nil {
		return x.FeeMultiplier
	}
	return ""
}

// An object describing a derivative market in the Injective Futures Protocol.
type DerivativeMarket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,2,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,3,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,5,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Address of the quote currency denomination for the derivative contract
	QuoteDenom string `protobuf:"bytes,6,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,7,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// initial_margin_ratio defines the initial margin ratio of a derivative
	// market
	InitialMarginRatio string `protobuf:"bytes,8,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3" json:"initial_margin_ratio,omitempty"`
	// maintenance_margin_ratio defines the maintenance margin ratio of a
	// derivative market
	MaintenanceMarginRatio string `protobuf:"bytes,9,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3" json:"maintenance_margin_ratio,omitempty"`
	// maker_fee_rate defines the maker fee rate of a derivative market
	MakerFeeRate string `protobuf:"bytes,10,opt,name=maker_fee_rate,json=makerFeeRate,proto3" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the taker fee rate of a derivative market
	TakerFeeRate string `protobuf:"bytes,11,opt,name=taker_fee_rate,json=takerFeeRate,proto3" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the percentage of the transaction fee shared
	// with the relayer in a derivative market
	RelayerFeeShareRate string `protobuf:"bytes,12,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3" json:"relayer_fee_share_rate,omitempty"`
	// true if the market is a perpetual market. false if the market is an expiry
	// futures market
	IsPerpetual bool `protobuf:"varint,13,opt,name=isPerpetual,proto3" json:"isPerpetual,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,14,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price and margin
	// required for orders in the market (in chain format)
	MinPriceTickSize string `protobuf:"bytes,15,opt,name=min_price_tick_size,json=minPriceTickSize,proto3" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market (in chain format)
	MinQuantityTickSize string `protobuf:"bytes,16,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3" json:"min_quantity_tick_size,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market (in chain format)
	MinNotional string `protobuf:"bytes,17,opt,name=min_notional,json=minNotional,proto3" json:"min_notional,omitempty"`
	// current market admin
	Admin string `protobuf:"bytes,18,opt,name=admin,proto3" json:"admin,omitempty"`
	// level of admin permissions
	AdminPermissions uint32 `protobuf:"varint,19,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,20,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
	// reduce_margin_ratio defines the ratio of the margin that is reduced
	ReduceMarginRatio string `protobuf:"bytes,21,opt,name=reduce_margin_ratio,json=reduceMarginRatio,proto3" json:"reduce_margin_ratio,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DerivativeMarket) Reset() {
	*x = DerivativeMarket{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeMarket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeMarket) ProtoMessage() {}

func (x *DerivativeMarket) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeMarket.ProtoReflect.Descriptor instead.
func (*DerivativeMarket) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{2}
}

func (x *DerivativeMarket) GetTicker() string {
	if x != nil {
		return x.Ticker
	}
	return ""
}

func (x *DerivativeMarket) GetOracleBase() string {
	if x != nil {
		return x.OracleBase
	}
	return ""
}

func (x *DerivativeMarket) GetOracleQuote() string {
	if x != nil {
		return x.OracleQuote
	}
	return ""
}

func (x *DerivativeMarket) GetOracleType() types1.OracleType {
	if x != nil {
		return x.OracleType
	}
	return types1.OracleType(0)
}

func (x *DerivativeMarket) GetOracleScaleFactor() uint32 {
	if x != nil {
		return x.OracleScaleFactor
	}
	return 0
}

func (x *DerivativeMarket) GetQuoteDenom() string {
	if x != nil {
		return x.QuoteDenom
	}
	return ""
}

func (x *DerivativeMarket) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *DerivativeMarket) GetInitialMarginRatio() string {
	if x != nil {
		return x.InitialMarginRatio
	}
	return ""
}

func (x *DerivativeMarket) GetMaintenanceMarginRatio() string {
	if x != nil {
		return x.MaintenanceMarginRatio
	}
	return ""
}

func (x *DerivativeMarket) GetMakerFeeRate() string {
	if x != nil {
		return x.MakerFeeRate
	}
	return ""
}

func (x *DerivativeMarket) GetTakerFeeRate() string {
	if x != nil {
		return x.TakerFeeRate
	}
	return ""
}

func (x *DerivativeMarket) GetRelayerFeeShareRate() string {
	if x != nil {
		return x.RelayerFeeShareRate
	}
	return ""
}

func (x *DerivativeMarket) GetIsPerpetual() bool {
	if x != nil {
		return x.IsPerpetual
	}
	return false
}

func (x *DerivativeMarket) GetStatus() MarketStatus {
	if x != nil {
		return x.Status
	}
	return MarketStatus_Unspecified
}

func (x *DerivativeMarket) GetMinPriceTickSize() string {
	if x != nil {
		return x.MinPriceTickSize
	}
	return ""
}

func (x *DerivativeMarket) GetMinQuantityTickSize() string {
	if x != nil {
		return x.MinQuantityTickSize
	}
	return ""
}

func (x *DerivativeMarket) GetMinNotional() string {
	if x != nil {
		return x.MinNotional
	}
	return ""
}

func (x *DerivativeMarket) GetAdmin() string {
	if x != nil {
		return x.Admin
	}
	return ""
}

func (x *DerivativeMarket) GetAdminPermissions() uint32 {
	if x != nil {
		return x.AdminPermissions
	}
	return 0
}

func (x *DerivativeMarket) GetQuoteDecimals() uint32 {
	if x != nil {
		return x.QuoteDecimals
	}
	return 0
}

func (x *DerivativeMarket) GetReduceMarginRatio() string {
	if x != nil {
		return x.ReduceMarginRatio
	}
	return ""
}

// An object describing a binary options market in Injective Protocol.
type BinaryOptionsMarket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle symbol
	OracleSymbol string `protobuf:"bytes,2,opt,name=oracle_symbol,json=oracleSymbol,proto3" json:"oracle_symbol,omitempty"`
	// Oracle Provider
	OracleProvider string `protobuf:"bytes,3,opt,name=oracle_provider,json=oracleProvider,proto3" json:"oracle_provider,omitempty"`
	// Oracle type
	OracleType types1.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,5,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,6,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,7,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// admin of the market
	Admin string `protobuf:"bytes,8,opt,name=admin,proto3" json:"admin,omitempty"`
	// Address of the quote currency denomination for the binary options contract
	QuoteDenom string `protobuf:"bytes,9,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,10,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// maker_fee_rate defines the maker fee rate of a binary options market
	MakerFeeRate string `protobuf:"bytes,11,opt,name=maker_fee_rate,json=makerFeeRate,proto3" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the taker fee rate of a derivative market
	TakerFeeRate string `protobuf:"bytes,12,opt,name=taker_fee_rate,json=takerFeeRate,proto3" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the percentage of the transaction fee shared
	// with the relayer in a derivative market
	RelayerFeeShareRate string `protobuf:"bytes,13,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3" json:"relayer_fee_share_rate,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,14,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price and margin
	// required for orders in the market
	MinPriceTickSize string `protobuf:"bytes,15,opt,name=min_price_tick_size,json=minPriceTickSize,proto3" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market
	MinQuantityTickSize string `protobuf:"bytes,16,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3" json:"min_quantity_tick_size,omitempty"`
	SettlementPrice     string `protobuf:"bytes,17,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlement_price,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market
	MinNotional string `protobuf:"bytes,18,opt,name=min_notional,json=minNotional,proto3" json:"min_notional,omitempty"`
	// level of admin permissions
	AdminPermissions uint32 `protobuf:"varint,19,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,20,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BinaryOptionsMarket) Reset() {
	*x = BinaryOptionsMarket{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BinaryOptionsMarket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BinaryOptionsMarket) ProtoMessage() {}

func (x *BinaryOptionsMarket) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BinaryOptionsMarket.ProtoReflect.Descriptor instead.
func (*BinaryOptionsMarket) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{3}
}

func (x *BinaryOptionsMarket) GetTicker() string {
	if x != nil {
		return x.Ticker
	}
	return ""
}

func (x *BinaryOptionsMarket) GetOracleSymbol() string {
	if x != nil {
		return x.OracleSymbol
	}
	return ""
}

func (x *BinaryOptionsMarket) GetOracleProvider() string {
	if x != nil {
		return x.OracleProvider
	}
	return ""
}

func (x *BinaryOptionsMarket) GetOracleType() types1.OracleType {
	if x != nil {
		return x.OracleType
	}
	return types1.OracleType(0)
}

func (x *BinaryOptionsMarket) GetOracleScaleFactor() uint32 {
	if x != nil {
		return x.OracleScaleFactor
	}
	return 0
}

func (x *BinaryOptionsMarket) GetExpirationTimestamp() int64 {
	if x != nil {
		return x.ExpirationTimestamp
	}
	return 0
}

func (x *BinaryOptionsMarket) GetSettlementTimestamp() int64 {
	if x != nil {
		return x.SettlementTimestamp
	}
	return 0
}

func (x *BinaryOptionsMarket) GetAdmin() string {
	if x != nil {
		return x.Admin
	}
	return ""
}

func (x *BinaryOptionsMarket) GetQuoteDenom() string {
	if x != nil {
		return x.QuoteDenom
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMakerFeeRate() string {
	if x != nil {
		return x.MakerFeeRate
	}
	return ""
}

func (x *BinaryOptionsMarket) GetTakerFeeRate() string {
	if x != nil {
		return x.TakerFeeRate
	}
	return ""
}

func (x *BinaryOptionsMarket) GetRelayerFeeShareRate() string {
	if x != nil {
		return x.RelayerFeeShareRate
	}
	return ""
}

func (x *BinaryOptionsMarket) GetStatus() MarketStatus {
	if x != nil {
		return x.Status
	}
	return MarketStatus_Unspecified
}

func (x *BinaryOptionsMarket) GetMinPriceTickSize() string {
	if x != nil {
		return x.MinPriceTickSize
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMinQuantityTickSize() string {
	if x != nil {
		return x.MinQuantityTickSize
	}
	return ""
}

func (x *BinaryOptionsMarket) GetSettlementPrice() string {
	if x != nil {
		return x.SettlementPrice
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMinNotional() string {
	if x != nil {
		return x.MinNotional
	}
	return ""
}

func (x *BinaryOptionsMarket) GetAdminPermissions() uint32 {
	if x != nil {
		return x.AdminPermissions
	}
	return 0
}

func (x *BinaryOptionsMarket) GetQuoteDecimals() uint32 {
	if x != nil {
		return x.QuoteDecimals
	}
	return 0
}

type ExpiryFuturesMarketInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market ID.
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// expiration_timestamp defines the expiration time for a time expiry futures
	// market.
	ExpirationTimestamp int64 `protobuf:"varint,2,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration_twap_start_timestamp defines the start time of the TWAP
	// calculation window
	TwapStartTimestamp int64 `protobuf:"varint,3,opt,name=twap_start_timestamp,json=twapStartTimestamp,proto3" json:"twap_start_timestamp,omitempty"`
	// expiration_twap_start_price_cumulative defines the cumulative price for the
	// start of the TWAP window (in chain format)
	ExpirationTwapStartPriceCumulative string `protobuf:"bytes,4,opt,name=expiration_twap_start_price_cumulative,json=expirationTwapStartPriceCumulative,proto3" json:"expiration_twap_start_price_cumulative,omitempty"`
	// settlement_price defines the settlement price for a time expiry futures
	// market (in chain format)
	SettlementPrice string `protobuf:"bytes,5,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlement_price,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ExpiryFuturesMarketInfo) Reset() {
	*x = ExpiryFuturesMarketInfo{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpiryFuturesMarketInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpiryFuturesMarketInfo) ProtoMessage() {}

func (x *ExpiryFuturesMarketInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpiryFuturesMarketInfo.ProtoReflect.Descriptor instead.
func (*ExpiryFuturesMarketInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{4}
}

func (x *ExpiryFuturesMarketInfo) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *ExpiryFuturesMarketInfo) GetExpirationTimestamp() int64 {
	if x != nil {
		return x.ExpirationTimestamp
	}
	return 0
}

func (x *ExpiryFuturesMarketInfo) GetTwapStartTimestamp() int64 {
	if x != nil {
		return x.TwapStartTimestamp
	}
	return 0
}

func (x *ExpiryFuturesMarketInfo) GetExpirationTwapStartPriceCumulative() string {
	if x != nil {
		return x.ExpirationTwapStartPriceCumulative
	}
	return ""
}

func (x *ExpiryFuturesMarketInfo) GetSettlementPrice() string {
	if x != nil {
		return x.SettlementPrice
	}
	return ""
}

type PerpetualMarketInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market ID.
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// hourly_funding_rate_cap defines the maximum absolute value of the hourly
	// funding rate
	HourlyFundingRateCap string `protobuf:"bytes,2,opt,name=hourly_funding_rate_cap,json=hourlyFundingRateCap,proto3" json:"hourly_funding_rate_cap,omitempty"`
	// hourly_interest_rate defines the hourly interest rate
	HourlyInterestRate string `protobuf:"bytes,3,opt,name=hourly_interest_rate,json=hourlyInterestRate,proto3" json:"hourly_interest_rate,omitempty"`
	// next_funding_timestamp defines the next funding timestamp in seconds of a
	// perpetual market
	NextFundingTimestamp int64 `protobuf:"varint,4,opt,name=next_funding_timestamp,json=nextFundingTimestamp,proto3" json:"next_funding_timestamp,omitempty"`
	// funding_interval defines the next funding interval in seconds of a
	// perpetual market.
	FundingInterval int64 `protobuf:"varint,5,opt,name=funding_interval,json=fundingInterval,proto3" json:"funding_interval,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PerpetualMarketInfo) Reset() {
	*x = PerpetualMarketInfo{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PerpetualMarketInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PerpetualMarketInfo) ProtoMessage() {}

func (x *PerpetualMarketInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PerpetualMarketInfo.ProtoReflect.Descriptor instead.
func (*PerpetualMarketInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{5}
}

func (x *PerpetualMarketInfo) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *PerpetualMarketInfo) GetHourlyFundingRateCap() string {
	if x != nil {
		return x.HourlyFundingRateCap
	}
	return ""
}

func (x *PerpetualMarketInfo) GetHourlyInterestRate() string {
	if x != nil {
		return x.HourlyInterestRate
	}
	return ""
}

func (x *PerpetualMarketInfo) GetNextFundingTimestamp() int64 {
	if x != nil {
		return x.NextFundingTimestamp
	}
	return 0
}

func (x *PerpetualMarketInfo) GetFundingInterval() int64 {
	if x != nil {
		return x.FundingInterval
	}
	return 0
}

type PerpetualMarketFunding struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cumulative_funding defines the cumulative funding of a perpetual market.
	CumulativeFunding string `protobuf:"bytes,1,opt,name=cumulative_funding,json=cumulativeFunding,proto3" json:"cumulative_funding,omitempty"`
	// cumulative_price defines the running time-integral of the perp premium
	// ((VWAP - mark_price) / mark_price) i.e., sum(premium * seconds)
	// used to compute the interval’s average premium for funding
	CumulativePrice string `protobuf:"bytes,2,opt,name=cumulative_price,json=cumulativePrice,proto3" json:"cumulative_price,omitempty"`
	// the last timestamp in seconds
	LastTimestamp int64 `protobuf:"varint,3,opt,name=last_timestamp,json=lastTimestamp,proto3" json:"last_timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PerpetualMarketFunding) Reset() {
	*x = PerpetualMarketFunding{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PerpetualMarketFunding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PerpetualMarketFunding) ProtoMessage() {}

func (x *PerpetualMarketFunding) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PerpetualMarketFunding.ProtoReflect.Descriptor instead.
func (*PerpetualMarketFunding) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{6}
}

func (x *PerpetualMarketFunding) GetCumulativeFunding() string {
	if x != nil {
		return x.CumulativeFunding
	}
	return ""
}

func (x *PerpetualMarketFunding) GetCumulativePrice() string {
	if x != nil {
		return x.CumulativePrice
	}
	return ""
}

func (x *PerpetualMarketFunding) GetLastTimestamp() int64 {
	if x != nil {
		return x.LastTimestamp
	}
	return 0
}

type DerivativeMarketSettlementInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market ID.
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// settlement_price defines the settlement price
	SettlementPrice string `protobuf:"bytes,2,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlement_price,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DerivativeMarketSettlementInfo) Reset() {
	*x = DerivativeMarketSettlementInfo{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeMarketSettlementInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeMarketSettlementInfo) ProtoMessage() {}

func (x *DerivativeMarketSettlementInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeMarketSettlementInfo.ProtoReflect.Descriptor instead.
func (*DerivativeMarketSettlementInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{7}
}

func (x *DerivativeMarketSettlementInfo) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *DerivativeMarketSettlementInfo) GetSettlementPrice() string {
	if x != nil {
		return x.SettlementPrice
	}
	return ""
}

type NextFundingTimestamp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NextTimestamp int64                  `protobuf:"varint,1,opt,name=next_timestamp,json=nextTimestamp,proto3" json:"next_timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NextFundingTimestamp) Reset() {
	*x = NextFundingTimestamp{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NextFundingTimestamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NextFundingTimestamp) ProtoMessage() {}

func (x *NextFundingTimestamp) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NextFundingTimestamp.ProtoReflect.Descriptor instead.
func (*NextFundingTimestamp) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{8}
}

func (x *NextFundingTimestamp) GetNextTimestamp() int64 {
	if x != nil {
		return x.NextTimestamp
	}
	return 0
}

type MidPriceAndTOB struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mid price of the market (in chain format)
	MidPrice string `protobuf:"bytes,1,opt,name=mid_price,json=midPrice,proto3" json:"mid_price,omitempty"`
	// best buy price of the market (in chain format)
	BestBuyPrice string `protobuf:"bytes,2,opt,name=best_buy_price,json=bestBuyPrice,proto3" json:"best_buy_price,omitempty"`
	// best sell price of the market (in chain format)
	BestSellPrice string `protobuf:"bytes,3,opt,name=best_sell_price,json=bestSellPrice,proto3" json:"best_sell_price,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MidPriceAndTOB) Reset() {
	*x = MidPriceAndTOB{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MidPriceAndTOB) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MidPriceAndTOB) ProtoMessage() {}

func (x *MidPriceAndTOB) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MidPriceAndTOB.ProtoReflect.Descriptor instead.
func (*MidPriceAndTOB) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{9}
}

func (x *MidPriceAndTOB) GetMidPrice() string {
	if x != nil {
		return x.MidPrice
	}
	return ""
}

func (x *MidPriceAndTOB) GetBestBuyPrice() string {
	if x != nil {
		return x.BestBuyPrice
	}
	return ""
}

func (x *MidPriceAndTOB) GetBestSellPrice() string {
	if x != nil {
		return x.BestSellPrice
	}
	return ""
}

// An object describing trade pair of two assets.
type SpotMarket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
	// asset.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Coin denom used for the base asset
	BaseDenom string `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	// Coin used for the quote asset
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// maker_fee_rate defines the fee percentage makers pay when trading
	MakerFeeRate string `protobuf:"bytes,4,opt,name=maker_fee_rate,json=makerFeeRate,proto3" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the fee percentage takers pay when trading
	TakerFeeRate string `protobuf:"bytes,5,opt,name=taker_fee_rate,json=takerFeeRate,proto3" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the percentage of the transaction fee shared
	// with the relayer in a derivative market
	RelayerFeeShareRate string `protobuf:"bytes,6,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3" json:"relayer_fee_share_rate,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,7,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,8,opt,name=status,proto3,enum=injective.exchange.v1beta1.MarketStatus" json:"status,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price required
	// for orders in the market (in chain format)
	MinPriceTickSize string `protobuf:"bytes,9,opt,name=min_price_tick_size,json=minPriceTickSize,proto3" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market (in chain format)
	MinQuantityTickSize string `protobuf:"bytes,10,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3" json:"min_quantity_tick_size,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market (in chain format)
	MinNotional string `protobuf:"bytes,11,opt,name=min_notional,json=minNotional,proto3" json:"min_notional,omitempty"`
	// current market admin
	Admin string `protobuf:"bytes,12,opt,name=admin,proto3" json:"admin,omitempty"`
	// level of admin permissions
	AdminPermissions uint32 `protobuf:"varint,13,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
	// base token decimals
	BaseDecimals uint32 `protobuf:"varint,14,opt,name=base_decimals,json=baseDecimals,proto3" json:"base_decimals,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,15,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpotMarket) Reset() {
	*x = SpotMarket{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotMarket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotMarket) ProtoMessage() {}

func (x *SpotMarket) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotMarket.ProtoReflect.Descriptor instead.
func (*SpotMarket) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{10}
}

func (x *SpotMarket) GetTicker() string {
	if x != nil {
		return x.Ticker
	}
	return ""
}

func (x *SpotMarket) GetBaseDenom() string {
	if x != nil {
		return x.BaseDenom
	}
	return ""
}

func (x *SpotMarket) GetQuoteDenom() string {
	if x != nil {
		return x.QuoteDenom
	}
	return ""
}

func (x *SpotMarket) GetMakerFeeRate() string {
	if x != nil {
		return x.MakerFeeRate
	}
	return ""
}

func (x *SpotMarket) GetTakerFeeRate() string {
	if x != nil {
		return x.TakerFeeRate
	}
	return ""
}

func (x *SpotMarket) GetRelayerFeeShareRate() string {
	if x != nil {
		return x.RelayerFeeShareRate
	}
	return ""
}

func (x *SpotMarket) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *SpotMarket) GetStatus() MarketStatus {
	if x != nil {
		return x.Status
	}
	return MarketStatus_Unspecified
}

func (x *SpotMarket) GetMinPriceTickSize() string {
	if x != nil {
		return x.MinPriceTickSize
	}
	return ""
}

func (x *SpotMarket) GetMinQuantityTickSize() string {
	if x != nil {
		return x.MinQuantityTickSize
	}
	return ""
}

func (x *SpotMarket) GetMinNotional() string {
	if x != nil {
		return x.MinNotional
	}
	return ""
}

func (x *SpotMarket) GetAdmin() string {
	if x != nil {
		return x.Admin
	}
	return ""
}

func (x *SpotMarket) GetAdminPermissions() uint32 {
	if x != nil {
		return x.AdminPermissions
	}
	return 0
}

func (x *SpotMarket) GetBaseDecimals() uint32 {
	if x != nil {
		return x.BaseDecimals
	}
	return 0
}

func (x *SpotMarket) GetQuoteDecimals() uint32 {
	if x != nil {
		return x.QuoteDecimals
	}
	return 0
}

// A subaccount's deposit for a given base currency
type Deposit struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	AvailableBalance string                 `protobuf:"bytes,1,opt,name=available_balance,json=availableBalance,proto3" json:"available_balance,omitempty"`
	TotalBalance     string                 `protobuf:"bytes,2,opt,name=total_balance,json=totalBalance,proto3" json:"total_balance,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Deposit) Reset() {
	*x = Deposit{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Deposit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Deposit) ProtoMessage() {}

func (x *Deposit) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Deposit.ProtoReflect.Descriptor instead.
func (*Deposit) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{11}
}

func (x *Deposit) GetAvailableBalance() string {
	if x != nil {
		return x.AvailableBalance
	}
	return ""
}

func (x *Deposit) GetTotalBalance() string {
	if x != nil {
		return x.TotalBalance
	}
	return ""
}

type SubaccountTradeNonce struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nonce         uint32                 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubaccountTradeNonce) Reset() {
	*x = SubaccountTradeNonce{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubaccountTradeNonce) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubaccountTradeNonce) ProtoMessage() {}

func (x *SubaccountTradeNonce) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubaccountTradeNonce.ProtoReflect.Descriptor instead.
func (*SubaccountTradeNonce) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{12}
}

func (x *SubaccountTradeNonce) GetNonce() uint32 {
	if x != nil {
		return x.Nonce
	}
	return 0
}

type OrderInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// bytes32 subaccount ID that created the order
	SubaccountId string `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// address fee_recipient address that will receive fees for the order
	FeeRecipient string `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	// price of the order
	Price string `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// quantity of the order
	Quantity      string `protobuf:"bytes,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Cid           string `protobuf:"bytes,5,opt,name=cid,proto3" json:"cid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderInfo) Reset() {
	*x = OrderInfo{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderInfo) ProtoMessage() {}

func (x *OrderInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderInfo.ProtoReflect.Descriptor instead.
func (*OrderInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{13}
}

func (x *OrderInfo) GetSubaccountId() string {
	if x != nil {
		return x.SubaccountId
	}
	return ""
}

func (x *OrderInfo) GetFeeRecipient() string {
	if x != nil {
		return x.FeeRecipient
	}
	return ""
}

func (x *OrderInfo) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *OrderInfo) GetQuantity() string {
	if x != nil {
		return x.Quantity
	}
	return ""
}

func (x *OrderInfo) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type SpotOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market_id represents the unique ID of the market
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,2,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,3,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v1beta1.OrderType" json:"order_type,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,4,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpotOrder) Reset() {
	*x = SpotOrder{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotOrder) ProtoMessage() {}

func (x *SpotOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotOrder.ProtoReflect.Descriptor instead.
func (*SpotOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{14}
}

func (x *SpotOrder) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *SpotOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *SpotOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *SpotOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

// A valid Spot limit order with Metadata.
type SpotLimitOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,2,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v1beta1.OrderType" json:"order_type,omitempty"`
	// the amount of the quantity remaining fillable
	Fillable string `protobuf:"bytes,3,opt,name=fillable,proto3" json:"fillable,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,4,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	OrderHash     []byte `protobuf:"bytes,5,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpotLimitOrder) Reset() {
	*x = SpotLimitOrder{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotLimitOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotLimitOrder) ProtoMessage() {}

func (x *SpotLimitOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotLimitOrder.ProtoReflect.Descriptor instead.
func (*SpotLimitOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{15}
}

func (x *SpotLimitOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *SpotLimitOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *SpotLimitOrder) GetFillable() string {
	if x != nil {
		return x.Fillable
	}
	return ""
}

func (x *SpotLimitOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *SpotLimitOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

// A valid Spot market order with Metadata.
type SpotMarketOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo   *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	BalanceHold string     `protobuf:"bytes,2,opt,name=balance_hold,json=balanceHold,proto3" json:"balance_hold,omitempty"`
	OrderHash   []byte     `protobuf:"bytes,3,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,4,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v1beta1.OrderType" json:"order_type,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpotMarketOrder) Reset() {
	*x = SpotMarketOrder{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotMarketOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotMarketOrder) ProtoMessage() {}

func (x *SpotMarketOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotMarketOrder.ProtoReflect.Descriptor instead.
func (*SpotMarketOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{16}
}

func (x *SpotMarketOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *SpotMarketOrder) GetBalanceHold() string {
	if x != nil {
		return x.BalanceHold
	}
	return ""
}

func (x *SpotMarketOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

func (x *SpotMarketOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *SpotMarketOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

type DerivativeOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market_id represents the unique ID of the market
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,2,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,3,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v1beta1.OrderType" json:"order_type,omitempty"`
	// margin is the margin used by the limit order
	Margin string `protobuf:"bytes,4,opt,name=margin,proto3" json:"margin,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DerivativeOrder) Reset() {
	*x = DerivativeOrder{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeOrder) ProtoMessage() {}

func (x *DerivativeOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeOrder.ProtoReflect.Descriptor instead.
func (*DerivativeOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{17}
}

func (x *DerivativeOrder) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *DerivativeOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *DerivativeOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *DerivativeOrder) GetMargin() string {
	if x != nil {
		return x.Margin
	}
	return ""
}

func (x *DerivativeOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

type SubaccountOrderbookMetadata struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The number of vanilla limit orders
	VanillaLimitOrderCount uint32 `protobuf:"varint,1,opt,name=vanilla_limit_order_count,json=vanillaLimitOrderCount,proto3" json:"vanilla_limit_order_count,omitempty"`
	// The number of reduce-only limit orders
	ReduceOnlyLimitOrderCount uint32 `protobuf:"varint,2,opt,name=reduce_only_limit_order_count,json=reduceOnlyLimitOrderCount,proto3" json:"reduce_only_limit_order_count,omitempty"`
	// The aggregate quantity of the subaccount's reduce-only limit orders (in
	// chain format)
	AggregateReduceOnlyQuantity string `protobuf:"bytes,3,opt,name=aggregate_reduce_only_quantity,json=aggregateReduceOnlyQuantity,proto3" json:"aggregate_reduce_only_quantity,omitempty"`
	// The aggregate quantity of the subaccount's vanilla limit orders (in chain
	// format)
	AggregateVanillaQuantity string `protobuf:"bytes,4,opt,name=aggregate_vanilla_quantity,json=aggregateVanillaQuantity,proto3" json:"aggregate_vanilla_quantity,omitempty"`
	// The number of vanilla conditional orders
	VanillaConditionalOrderCount uint32 `protobuf:"varint,5,opt,name=vanilla_conditional_order_count,json=vanillaConditionalOrderCount,proto3" json:"vanilla_conditional_order_count,omitempty"`
	// The number of reduce-only conditional orders
	ReduceOnlyConditionalOrderCount uint32 `protobuf:"varint,6,opt,name=reduce_only_conditional_order_count,json=reduceOnlyConditionalOrderCount,proto3" json:"reduce_only_conditional_order_count,omitempty"`
	unknownFields                   protoimpl.UnknownFields
	sizeCache                       protoimpl.SizeCache
}

func (x *SubaccountOrderbookMetadata) Reset() {
	*x = SubaccountOrderbookMetadata{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubaccountOrderbookMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubaccountOrderbookMetadata) ProtoMessage() {}

func (x *SubaccountOrderbookMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubaccountOrderbookMetadata.ProtoReflect.Descriptor instead.
func (*SubaccountOrderbookMetadata) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{18}
}

func (x *SubaccountOrderbookMetadata) GetVanillaLimitOrderCount() uint32 {
	if x != nil {
		return x.VanillaLimitOrderCount
	}
	return 0
}

func (x *SubaccountOrderbookMetadata) GetReduceOnlyLimitOrderCount() uint32 {
	if x != nil {
		return x.ReduceOnlyLimitOrderCount
	}
	return 0
}

func (x *SubaccountOrderbookMetadata) GetAggregateReduceOnlyQuantity() string {
	if x != nil {
		return x.AggregateReduceOnlyQuantity
	}
	return ""
}

func (x *SubaccountOrderbookMetadata) GetAggregateVanillaQuantity() string {
	if x != nil {
		return x.AggregateVanillaQuantity
	}
	return ""
}

func (x *SubaccountOrderbookMetadata) GetVanillaConditionalOrderCount() uint32 {
	if x != nil {
		return x.VanillaConditionalOrderCount
	}
	return 0
}

func (x *SubaccountOrderbookMetadata) GetReduceOnlyConditionalOrderCount() uint32 {
	if x != nil {
		return x.ReduceOnlyConditionalOrderCount
	}
	return 0
}

type SubaccountOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// price of the order
	Price string `protobuf:"bytes,1,opt,name=price,proto3" json:"price,omitempty"`
	// the amount of the quantity remaining fillable
	Quantity      string `protobuf:"bytes,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	IsReduceOnly  bool   `protobuf:"varint,3,opt,name=isReduceOnly,proto3" json:"isReduceOnly,omitempty"`
	Cid           string `protobuf:"bytes,4,opt,name=cid,proto3" json:"cid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubaccountOrder) Reset() {
	*x = SubaccountOrder{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubaccountOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubaccountOrder) ProtoMessage() {}

func (x *SubaccountOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubaccountOrder.ProtoReflect.Descriptor instead.
func (*SubaccountOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{19}
}

func (x *SubaccountOrder) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *SubaccountOrder) GetQuantity() string {
	if x != nil {
		return x.Quantity
	}
	return ""
}

func (x *SubaccountOrder) GetIsReduceOnly() bool {
	if x != nil {
		return x.IsReduceOnly
	}
	return false
}

func (x *SubaccountOrder) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type SubaccountOrderData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Order         *SubaccountOrder       `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	OrderHash     []byte                 `protobuf:"bytes,2,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubaccountOrderData) Reset() {
	*x = SubaccountOrderData{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubaccountOrderData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubaccountOrderData) ProtoMessage() {}

func (x *SubaccountOrderData) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubaccountOrderData.ProtoReflect.Descriptor instead.
func (*SubaccountOrderData) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{20}
}

func (x *SubaccountOrderData) GetOrder() *SubaccountOrder {
	if x != nil {
		return x.Order
	}
	return nil
}

func (x *SubaccountOrderData) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

// A valid Derivative limit order with Metadata.
type DerivativeLimitOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,2,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v1beta1.OrderType" json:"order_type,omitempty"`
	// margin is the margin used by the limit order
	Margin string `protobuf:"bytes,3,opt,name=margin,proto3" json:"margin,omitempty"`
	// the amount of the quantity remaining fillable
	Fillable string `protobuf:"bytes,4,opt,name=fillable,proto3" json:"fillable,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	OrderHash     []byte `protobuf:"bytes,6,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DerivativeLimitOrder) Reset() {
	*x = DerivativeLimitOrder{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeLimitOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeLimitOrder) ProtoMessage() {}

func (x *DerivativeLimitOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeLimitOrder.ProtoReflect.Descriptor instead.
func (*DerivativeLimitOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{21}
}

func (x *DerivativeLimitOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *DerivativeLimitOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *DerivativeLimitOrder) GetMargin() string {
	if x != nil {
		return x.Margin
	}
	return ""
}

func (x *DerivativeLimitOrder) GetFillable() string {
	if x != nil {
		return x.Fillable
	}
	return ""
}

func (x *DerivativeLimitOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *DerivativeLimitOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

// A valid Derivative market order with Metadata.
type DerivativeMarketOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType  OrderType `protobuf:"varint,2,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v1beta1.OrderType" json:"order_type,omitempty"`
	Margin     string    `protobuf:"bytes,3,opt,name=margin,proto3" json:"margin,omitempty"`
	MarginHold string    `protobuf:"bytes,4,opt,name=margin_hold,json=marginHold,proto3" json:"margin_hold,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	OrderHash     []byte `protobuf:"bytes,6,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DerivativeMarketOrder) Reset() {
	*x = DerivativeMarketOrder{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeMarketOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeMarketOrder) ProtoMessage() {}

func (x *DerivativeMarketOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeMarketOrder.ProtoReflect.Descriptor instead.
func (*DerivativeMarketOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{22}
}

func (x *DerivativeMarketOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *DerivativeMarketOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *DerivativeMarketOrder) GetMargin() string {
	if x != nil {
		return x.Margin
	}
	return ""
}

func (x *DerivativeMarketOrder) GetMarginHold() string {
	if x != nil {
		return x.MarginHold
	}
	return ""
}

func (x *DerivativeMarketOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *DerivativeMarketOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

type Position struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// True if the position is long. False if the position is short.
	IsLong bool `protobuf:"varint,1,opt,name=isLong,proto3" json:"isLong,omitempty"`
	// The quantity of the position (in chain format)
	Quantity string `protobuf:"bytes,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// The entry price of the position (in chain format)
	EntryPrice string `protobuf:"bytes,3,opt,name=entry_price,json=entryPrice,proto3" json:"entry_price,omitempty"`
	// The margin of the position (in chain format)
	Margin string `protobuf:"bytes,4,opt,name=margin,proto3" json:"margin,omitempty"`
	// The cumulative funding
	CumulativeFundingEntry string `protobuf:"bytes,5,opt,name=cumulative_funding_entry,json=cumulativeFundingEntry,proto3" json:"cumulative_funding_entry,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *Position) Reset() {
	*x = Position{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Position) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Position) ProtoMessage() {}

func (x *Position) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Position.ProtoReflect.Descriptor instead.
func (*Position) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{23}
}

func (x *Position) GetIsLong() bool {
	if x != nil {
		return x.IsLong
	}
	return false
}

func (x *Position) GetQuantity() string {
	if x != nil {
		return x.Quantity
	}
	return ""
}

func (x *Position) GetEntryPrice() string {
	if x != nil {
		return x.EntryPrice
	}
	return ""
}

func (x *Position) GetMargin() string {
	if x != nil {
		return x.Margin
	}
	return ""
}

func (x *Position) GetCumulativeFundingEntry() string {
	if x != nil {
		return x.CumulativeFundingEntry
	}
	return ""
}

type MarketOrderIndicator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market_id represents the unique ID of the market
	MarketId      string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	IsBuy         bool   `protobuf:"varint,2,opt,name=isBuy,proto3" json:"isBuy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketOrderIndicator) Reset() {
	*x = MarketOrderIndicator{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketOrderIndicator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketOrderIndicator) ProtoMessage() {}

func (x *MarketOrderIndicator) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketOrderIndicator.ProtoReflect.Descriptor instead.
func (*MarketOrderIndicator) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{24}
}

func (x *MarketOrderIndicator) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *MarketOrderIndicator) GetIsBuy() bool {
	if x != nil {
		return x.IsBuy
	}
	return false
}

type TradeLog struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Quantity string                 `protobuf:"bytes,1,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Price    string                 `protobuf:"bytes,2,opt,name=price,proto3" json:"price,omitempty"`
	// bytes32 subaccount ID that executed the trade
	SubaccountId        []byte `protobuf:"bytes,3,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Fee                 string `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	OrderHash           []byte `protobuf:"bytes,5,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	FeeRecipientAddress []byte `protobuf:"bytes,6,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	Cid                 string `protobuf:"bytes,7,opt,name=cid,proto3" json:"cid,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *TradeLog) Reset() {
	*x = TradeLog{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TradeLog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradeLog) ProtoMessage() {}

func (x *TradeLog) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradeLog.ProtoReflect.Descriptor instead.
func (*TradeLog) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{25}
}

func (x *TradeLog) GetQuantity() string {
	if x != nil {
		return x.Quantity
	}
	return ""
}

func (x *TradeLog) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *TradeLog) GetSubaccountId() []byte {
	if x != nil {
		return x.SubaccountId
	}
	return nil
}

func (x *TradeLog) GetFee() string {
	if x != nil {
		return x.Fee
	}
	return ""
}

func (x *TradeLog) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

func (x *TradeLog) GetFeeRecipientAddress() []byte {
	if x != nil {
		return x.FeeRecipientAddress
	}
	return nil
}

func (x *TradeLog) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type PositionDelta struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IsLong            bool                   `protobuf:"varint,1,opt,name=is_long,json=isLong,proto3" json:"is_long,omitempty"`
	ExecutionQuantity string                 `protobuf:"bytes,2,opt,name=execution_quantity,json=executionQuantity,proto3" json:"execution_quantity,omitempty"`
	ExecutionMargin   string                 `protobuf:"bytes,3,opt,name=execution_margin,json=executionMargin,proto3" json:"execution_margin,omitempty"`
	ExecutionPrice    string                 `protobuf:"bytes,4,opt,name=execution_price,json=executionPrice,proto3" json:"execution_price,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PositionDelta) Reset() {
	*x = PositionDelta{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PositionDelta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PositionDelta) ProtoMessage() {}

func (x *PositionDelta) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PositionDelta.ProtoReflect.Descriptor instead.
func (*PositionDelta) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{26}
}

func (x *PositionDelta) GetIsLong() bool {
	if x != nil {
		return x.IsLong
	}
	return false
}

func (x *PositionDelta) GetExecutionQuantity() string {
	if x != nil {
		return x.ExecutionQuantity
	}
	return ""
}

func (x *PositionDelta) GetExecutionMargin() string {
	if x != nil {
		return x.ExecutionMargin
	}
	return ""
}

func (x *PositionDelta) GetExecutionPrice() string {
	if x != nil {
		return x.ExecutionPrice
	}
	return ""
}

type DerivativeTradeLog struct {
	state               protoimpl.MessageState `protogen:"open.v1"`
	SubaccountId        []byte                 `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	PositionDelta       *PositionDelta         `protobuf:"bytes,2,opt,name=position_delta,json=positionDelta,proto3" json:"position_delta,omitempty"`
	Payout              string                 `protobuf:"bytes,3,opt,name=payout,proto3" json:"payout,omitempty"`
	Fee                 string                 `protobuf:"bytes,4,opt,name=fee,proto3" json:"fee,omitempty"`
	OrderHash           []byte                 `protobuf:"bytes,5,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	FeeRecipientAddress []byte                 `protobuf:"bytes,6,opt,name=fee_recipient_address,json=feeRecipientAddress,proto3" json:"fee_recipient_address,omitempty"`
	Cid                 string                 `protobuf:"bytes,7,opt,name=cid,proto3" json:"cid,omitempty"`
	Pnl                 string                 `protobuf:"bytes,8,opt,name=pnl,proto3" json:"pnl,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *DerivativeTradeLog) Reset() {
	*x = DerivativeTradeLog{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeTradeLog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeTradeLog) ProtoMessage() {}

func (x *DerivativeTradeLog) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeTradeLog.ProtoReflect.Descriptor instead.
func (*DerivativeTradeLog) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{27}
}

func (x *DerivativeTradeLog) GetSubaccountId() []byte {
	if x != nil {
		return x.SubaccountId
	}
	return nil
}

func (x *DerivativeTradeLog) GetPositionDelta() *PositionDelta {
	if x != nil {
		return x.PositionDelta
	}
	return nil
}

func (x *DerivativeTradeLog) GetPayout() string {
	if x != nil {
		return x.Payout
	}
	return ""
}

func (x *DerivativeTradeLog) GetFee() string {
	if x != nil {
		return x.Fee
	}
	return ""
}

func (x *DerivativeTradeLog) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

func (x *DerivativeTradeLog) GetFeeRecipientAddress() []byte {
	if x != nil {
		return x.FeeRecipientAddress
	}
	return nil
}

func (x *DerivativeTradeLog) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

func (x *DerivativeTradeLog) GetPnl() string {
	if x != nil {
		return x.Pnl
	}
	return ""
}

type SubaccountPosition struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Position      *Position              `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	SubaccountId  []byte                 `protobuf:"bytes,2,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubaccountPosition) Reset() {
	*x = SubaccountPosition{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubaccountPosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubaccountPosition) ProtoMessage() {}

func (x *SubaccountPosition) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubaccountPosition.ProtoReflect.Descriptor instead.
func (*SubaccountPosition) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{28}
}

func (x *SubaccountPosition) GetPosition() *Position {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *SubaccountPosition) GetSubaccountId() []byte {
	if x != nil {
		return x.SubaccountId
	}
	return nil
}

type SubaccountDeposit struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SubaccountId  []byte                 `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	Deposit       *Deposit               `protobuf:"bytes,2,opt,name=deposit,proto3" json:"deposit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubaccountDeposit) Reset() {
	*x = SubaccountDeposit{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubaccountDeposit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubaccountDeposit) ProtoMessage() {}

func (x *SubaccountDeposit) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubaccountDeposit.ProtoReflect.Descriptor instead.
func (*SubaccountDeposit) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{29}
}

func (x *SubaccountDeposit) GetSubaccountId() []byte {
	if x != nil {
		return x.SubaccountId
	}
	return nil
}

func (x *SubaccountDeposit) GetDeposit() *Deposit {
	if x != nil {
		return x.Deposit
	}
	return nil
}

type DepositUpdate struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Denom         string                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Deposits      []*SubaccountDeposit   `protobuf:"bytes,2,rep,name=deposits,proto3" json:"deposits,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DepositUpdate) Reset() {
	*x = DepositUpdate{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DepositUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DepositUpdate) ProtoMessage() {}

func (x *DepositUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DepositUpdate.ProtoReflect.Descriptor instead.
func (*DepositUpdate) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{30}
}

func (x *DepositUpdate) GetDenom() string {
	if x != nil {
		return x.Denom
	}
	return ""
}

func (x *DepositUpdate) GetDeposits() []*SubaccountDeposit {
	if x != nil {
		return x.Deposits
	}
	return nil
}

type PointsMultiplier struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	MakerPointsMultiplier string                 `protobuf:"bytes,1,opt,name=maker_points_multiplier,json=makerPointsMultiplier,proto3" json:"maker_points_multiplier,omitempty"`
	TakerPointsMultiplier string                 `protobuf:"bytes,2,opt,name=taker_points_multiplier,json=takerPointsMultiplier,proto3" json:"taker_points_multiplier,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *PointsMultiplier) Reset() {
	*x = PointsMultiplier{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PointsMultiplier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PointsMultiplier) ProtoMessage() {}

func (x *PointsMultiplier) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PointsMultiplier.ProtoReflect.Descriptor instead.
func (*PointsMultiplier) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{31}
}

func (x *PointsMultiplier) GetMakerPointsMultiplier() string {
	if x != nil {
		return x.MakerPointsMultiplier
	}
	return ""
}

func (x *PointsMultiplier) GetTakerPointsMultiplier() string {
	if x != nil {
		return x.TakerPointsMultiplier
	}
	return ""
}

type TradingRewardCampaignBoostInfo struct {
	state                       protoimpl.MessageState `protogen:"open.v1"`
	BoostedSpotMarketIds        []string               `protobuf:"bytes,1,rep,name=boosted_spot_market_ids,json=boostedSpotMarketIds,proto3" json:"boosted_spot_market_ids,omitempty"`
	SpotMarketMultipliers       []*PointsMultiplier    `protobuf:"bytes,2,rep,name=spot_market_multipliers,json=spotMarketMultipliers,proto3" json:"spot_market_multipliers,omitempty"`
	BoostedDerivativeMarketIds  []string               `protobuf:"bytes,3,rep,name=boosted_derivative_market_ids,json=boostedDerivativeMarketIds,proto3" json:"boosted_derivative_market_ids,omitempty"`
	DerivativeMarketMultipliers []*PointsMultiplier    `protobuf:"bytes,4,rep,name=derivative_market_multipliers,json=derivativeMarketMultipliers,proto3" json:"derivative_market_multipliers,omitempty"`
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *TradingRewardCampaignBoostInfo) Reset() {
	*x = TradingRewardCampaignBoostInfo{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TradingRewardCampaignBoostInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradingRewardCampaignBoostInfo) ProtoMessage() {}

func (x *TradingRewardCampaignBoostInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradingRewardCampaignBoostInfo.ProtoReflect.Descriptor instead.
func (*TradingRewardCampaignBoostInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{32}
}

func (x *TradingRewardCampaignBoostInfo) GetBoostedSpotMarketIds() []string {
	if x != nil {
		return x.BoostedSpotMarketIds
	}
	return nil
}

func (x *TradingRewardCampaignBoostInfo) GetSpotMarketMultipliers() []*PointsMultiplier {
	if x != nil {
		return x.SpotMarketMultipliers
	}
	return nil
}

func (x *TradingRewardCampaignBoostInfo) GetBoostedDerivativeMarketIds() []string {
	if x != nil {
		return x.BoostedDerivativeMarketIds
	}
	return nil
}

func (x *TradingRewardCampaignBoostInfo) GetDerivativeMarketMultipliers() []*PointsMultiplier {
	if x != nil {
		return x.DerivativeMarketMultipliers
	}
	return nil
}

type CampaignRewardPool struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	StartTimestamp int64                  `protobuf:"varint,1,opt,name=start_timestamp,json=startTimestamp,proto3" json:"start_timestamp,omitempty"`
	// max_campaign_rewards are the maximum reward amounts to be disbursed at the
	// end of the campaign
	MaxCampaignRewards []*types.Coin `protobuf:"bytes,2,rep,name=max_campaign_rewards,json=maxCampaignRewards,proto3" json:"max_campaign_rewards,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *CampaignRewardPool) Reset() {
	*x = CampaignRewardPool{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CampaignRewardPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CampaignRewardPool) ProtoMessage() {}

func (x *CampaignRewardPool) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CampaignRewardPool.ProtoReflect.Descriptor instead.
func (*CampaignRewardPool) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{33}
}

func (x *CampaignRewardPool) GetStartTimestamp() int64 {
	if x != nil {
		return x.StartTimestamp
	}
	return 0
}

func (x *CampaignRewardPool) GetMaxCampaignRewards() []*types.Coin {
	if x != nil {
		return x.MaxCampaignRewards
	}
	return nil
}

type TradingRewardCampaignInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// number of seconds of the duration of each campaign
	CampaignDurationSeconds int64 `protobuf:"varint,1,opt,name=campaign_duration_seconds,json=campaignDurationSeconds,proto3" json:"campaign_duration_seconds,omitempty"`
	// the trading fee quote denoms which will be counted for the rewards
	QuoteDenoms []string `protobuf:"bytes,2,rep,name=quote_denoms,json=quoteDenoms,proto3" json:"quote_denoms,omitempty"`
	// the optional boost info for markets
	TradingRewardBoostInfo *TradingRewardCampaignBoostInfo `protobuf:"bytes,3,opt,name=trading_reward_boost_info,json=tradingRewardBoostInfo,proto3" json:"trading_reward_boost_info,omitempty"`
	// the marketIDs which are disqualified from being rewarded
	DisqualifiedMarketIds []string `protobuf:"bytes,4,rep,name=disqualified_market_ids,json=disqualifiedMarketIds,proto3" json:"disqualified_market_ids,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *TradingRewardCampaignInfo) Reset() {
	*x = TradingRewardCampaignInfo{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TradingRewardCampaignInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradingRewardCampaignInfo) ProtoMessage() {}

func (x *TradingRewardCampaignInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradingRewardCampaignInfo.ProtoReflect.Descriptor instead.
func (*TradingRewardCampaignInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{34}
}

func (x *TradingRewardCampaignInfo) GetCampaignDurationSeconds() int64 {
	if x != nil {
		return x.CampaignDurationSeconds
	}
	return 0
}

func (x *TradingRewardCampaignInfo) GetQuoteDenoms() []string {
	if x != nil {
		return x.QuoteDenoms
	}
	return nil
}

func (x *TradingRewardCampaignInfo) GetTradingRewardBoostInfo() *TradingRewardCampaignBoostInfo {
	if x != nil {
		return x.TradingRewardBoostInfo
	}
	return nil
}

func (x *TradingRewardCampaignInfo) GetDisqualifiedMarketIds() []string {
	if x != nil {
		return x.DisqualifiedMarketIds
	}
	return nil
}

type FeeDiscountTierInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the maker discount rate
	MakerDiscountRate string `protobuf:"bytes,1,opt,name=maker_discount_rate,json=makerDiscountRate,proto3" json:"maker_discount_rate,omitempty"`
	// the taker discount rate
	TakerDiscountRate string `protobuf:"bytes,2,opt,name=taker_discount_rate,json=takerDiscountRate,proto3" json:"taker_discount_rate,omitempty"`
	// the staked amount required to qualify for the discount (in chain format)
	StakedAmount string `protobuf:"bytes,3,opt,name=staked_amount,json=stakedAmount,proto3" json:"staked_amount,omitempty"`
	// the volume required to qualify for the discount (in chain format)
	Volume        string `protobuf:"bytes,4,opt,name=volume,proto3" json:"volume,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeeDiscountTierInfo) Reset() {
	*x = FeeDiscountTierInfo{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeeDiscountTierInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeeDiscountTierInfo) ProtoMessage() {}

func (x *FeeDiscountTierInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeeDiscountTierInfo.ProtoReflect.Descriptor instead.
func (*FeeDiscountTierInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{35}
}

func (x *FeeDiscountTierInfo) GetMakerDiscountRate() string {
	if x != nil {
		return x.MakerDiscountRate
	}
	return ""
}

func (x *FeeDiscountTierInfo) GetTakerDiscountRate() string {
	if x != nil {
		return x.TakerDiscountRate
	}
	return ""
}

func (x *FeeDiscountTierInfo) GetStakedAmount() string {
	if x != nil {
		return x.StakedAmount
	}
	return ""
}

func (x *FeeDiscountTierInfo) GetVolume() string {
	if x != nil {
		return x.Volume
	}
	return ""
}

type FeeDiscountSchedule struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	BucketCount    uint64                 `protobuf:"varint,1,opt,name=bucket_count,json=bucketCount,proto3" json:"bucket_count,omitempty"`
	BucketDuration int64                  `protobuf:"varint,2,opt,name=bucket_duration,json=bucketDuration,proto3" json:"bucket_duration,omitempty"`
	// the trading fee quote denoms which will be counted for the fee paid
	// contribution
	QuoteDenoms []string `protobuf:"bytes,3,rep,name=quote_denoms,json=quoteDenoms,proto3" json:"quote_denoms,omitempty"`
	// the fee discount tiers
	TierInfos []*FeeDiscountTierInfo `protobuf:"bytes,4,rep,name=tier_infos,json=tierInfos,proto3" json:"tier_infos,omitempty"`
	// the marketIDs which are disqualified from contributing to the fee paid
	// amount
	DisqualifiedMarketIds []string `protobuf:"bytes,5,rep,name=disqualified_market_ids,json=disqualifiedMarketIds,proto3" json:"disqualified_market_ids,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *FeeDiscountSchedule) Reset() {
	*x = FeeDiscountSchedule{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeeDiscountSchedule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeeDiscountSchedule) ProtoMessage() {}

func (x *FeeDiscountSchedule) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeeDiscountSchedule.ProtoReflect.Descriptor instead.
func (*FeeDiscountSchedule) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{36}
}

func (x *FeeDiscountSchedule) GetBucketCount() uint64 {
	if x != nil {
		return x.BucketCount
	}
	return 0
}

func (x *FeeDiscountSchedule) GetBucketDuration() int64 {
	if x != nil {
		return x.BucketDuration
	}
	return 0
}

func (x *FeeDiscountSchedule) GetQuoteDenoms() []string {
	if x != nil {
		return x.QuoteDenoms
	}
	return nil
}

func (x *FeeDiscountSchedule) GetTierInfos() []*FeeDiscountTierInfo {
	if x != nil {
		return x.TierInfos
	}
	return nil
}

func (x *FeeDiscountSchedule) GetDisqualifiedMarketIds() []string {
	if x != nil {
		return x.DisqualifiedMarketIds
	}
	return nil
}

type FeeDiscountTierTTL struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Tier          uint64                 `protobuf:"varint,1,opt,name=tier,proto3" json:"tier,omitempty"`
	TtlTimestamp  int64                  `protobuf:"varint,2,opt,name=ttl_timestamp,json=ttlTimestamp,proto3" json:"ttl_timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeeDiscountTierTTL) Reset() {
	*x = FeeDiscountTierTTL{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeeDiscountTierTTL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeeDiscountTierTTL) ProtoMessage() {}

func (x *FeeDiscountTierTTL) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeeDiscountTierTTL.ProtoReflect.Descriptor instead.
func (*FeeDiscountTierTTL) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{37}
}

func (x *FeeDiscountTierTTL) GetTier() uint64 {
	if x != nil {
		return x.Tier
	}
	return 0
}

func (x *FeeDiscountTierTTL) GetTtlTimestamp() int64 {
	if x != nil {
		return x.TtlTimestamp
	}
	return 0
}

type VolumeRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MakerVolume   string                 `protobuf:"bytes,1,opt,name=maker_volume,json=makerVolume,proto3" json:"maker_volume,omitempty"`
	TakerVolume   string                 `protobuf:"bytes,2,opt,name=taker_volume,json=takerVolume,proto3" json:"taker_volume,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeRecord) Reset() {
	*x = VolumeRecord{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeRecord) ProtoMessage() {}

func (x *VolumeRecord) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeRecord.ProtoReflect.Descriptor instead.
func (*VolumeRecord) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{38}
}

func (x *VolumeRecord) GetMakerVolume() string {
	if x != nil {
		return x.MakerVolume
	}
	return ""
}

func (x *VolumeRecord) GetTakerVolume() string {
	if x != nil {
		return x.TakerVolume
	}
	return ""
}

type AccountRewards struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Account       string                 `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	Rewards       []*types.Coin          `protobuf:"bytes,2,rep,name=rewards,proto3" json:"rewards,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AccountRewards) Reset() {
	*x = AccountRewards{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AccountRewards) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AccountRewards) ProtoMessage() {}

func (x *AccountRewards) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AccountRewards.ProtoReflect.Descriptor instead.
func (*AccountRewards) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{39}
}

func (x *AccountRewards) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

func (x *AccountRewards) GetRewards() []*types.Coin {
	if x != nil {
		return x.Rewards
	}
	return nil
}

type TradeRecords struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	MarketId           string                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	LatestTradeRecords []*TradeRecord         `protobuf:"bytes,2,rep,name=latest_trade_records,json=latestTradeRecords,proto3" json:"latest_trade_records,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *TradeRecords) Reset() {
	*x = TradeRecords{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TradeRecords) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradeRecords) ProtoMessage() {}

func (x *TradeRecords) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradeRecords.ProtoReflect.Descriptor instead.
func (*TradeRecords) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{40}
}

func (x *TradeRecords) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *TradeRecords) GetLatestTradeRecords() []*TradeRecord {
	if x != nil {
		return x.LatestTradeRecords
	}
	return nil
}

type SubaccountIDs struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SubaccountIds [][]byte               `protobuf:"bytes,1,rep,name=subaccount_ids,json=subaccountIds,proto3" json:"subaccount_ids,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubaccountIDs) Reset() {
	*x = SubaccountIDs{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubaccountIDs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubaccountIDs) ProtoMessage() {}

func (x *SubaccountIDs) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubaccountIDs.ProtoReflect.Descriptor instead.
func (*SubaccountIDs) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{41}
}

func (x *SubaccountIDs) GetSubaccountIds() [][]byte {
	if x != nil {
		return x.SubaccountIds
	}
	return nil
}

type TradeRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the timestamp of the trade
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// the price of the trade (in chain format)
	Price string `protobuf:"bytes,2,opt,name=price,proto3" json:"price,omitempty"`
	// the quantity of the trade (in chain format)
	Quantity      string `protobuf:"bytes,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TradeRecord) Reset() {
	*x = TradeRecord{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TradeRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TradeRecord) ProtoMessage() {}

func (x *TradeRecord) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TradeRecord.ProtoReflect.Descriptor instead.
func (*TradeRecord) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{42}
}

func (x *TradeRecord) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *TradeRecord) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *TradeRecord) GetQuantity() string {
	if x != nil {
		return x.Quantity
	}
	return ""
}

type Level struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// price (in chain format)
	P string `protobuf:"bytes,1,opt,name=p,proto3" json:"p,omitempty"`
	// quantity (in chain format)
	Q             string `protobuf:"bytes,2,opt,name=q,proto3" json:"q,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Level) Reset() {
	*x = Level{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Level) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Level) ProtoMessage() {}

func (x *Level) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Level.ProtoReflect.Descriptor instead.
func (*Level) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{43}
}

func (x *Level) GetP() string {
	if x != nil {
		return x.P
	}
	return ""
}

func (x *Level) GetQ() string {
	if x != nil {
		return x.Q
	}
	return ""
}

type AggregateSubaccountVolumeRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the subaccount ID
	SubaccountId string `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// the subaccount volumes for each market
	MarketVolumes []*MarketVolume `protobuf:"bytes,2,rep,name=market_volumes,json=marketVolumes,proto3" json:"market_volumes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AggregateSubaccountVolumeRecord) Reset() {
	*x = AggregateSubaccountVolumeRecord{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregateSubaccountVolumeRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregateSubaccountVolumeRecord) ProtoMessage() {}

func (x *AggregateSubaccountVolumeRecord) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregateSubaccountVolumeRecord.ProtoReflect.Descriptor instead.
func (*AggregateSubaccountVolumeRecord) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{44}
}

func (x *AggregateSubaccountVolumeRecord) GetSubaccountId() string {
	if x != nil {
		return x.SubaccountId
	}
	return ""
}

func (x *AggregateSubaccountVolumeRecord) GetMarketVolumes() []*MarketVolume {
	if x != nil {
		return x.MarketVolumes
	}
	return nil
}

type AggregateAccountVolumeRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Account       string                 `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	MarketVolumes []*MarketVolume        `protobuf:"bytes,2,rep,name=market_volumes,json=marketVolumes,proto3" json:"market_volumes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AggregateAccountVolumeRecord) Reset() {
	*x = AggregateAccountVolumeRecord{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AggregateAccountVolumeRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AggregateAccountVolumeRecord) ProtoMessage() {}

func (x *AggregateAccountVolumeRecord) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AggregateAccountVolumeRecord.ProtoReflect.Descriptor instead.
func (*AggregateAccountVolumeRecord) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{45}
}

func (x *AggregateAccountVolumeRecord) GetAccount() string {
	if x != nil {
		return x.Account
	}
	return ""
}

func (x *AggregateAccountVolumeRecord) GetMarketVolumes() []*MarketVolume {
	if x != nil {
		return x.MarketVolumes
	}
	return nil
}

type MarketVolume struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MarketId      string                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Volume        *VolumeRecord          `protobuf:"bytes,2,opt,name=volume,proto3" json:"volume,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketVolume) Reset() {
	*x = MarketVolume{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketVolume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketVolume) ProtoMessage() {}

func (x *MarketVolume) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketVolume.ProtoReflect.Descriptor instead.
func (*MarketVolume) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{46}
}

func (x *MarketVolume) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *MarketVolume) GetVolume() *VolumeRecord {
	if x != nil {
		return x.Volume
	}
	return nil
}

type DenomDecimals struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Denom         string                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Decimals      uint64                 `protobuf:"varint,2,opt,name=decimals,proto3" json:"decimals,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DenomDecimals) Reset() {
	*x = DenomDecimals{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DenomDecimals) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DenomDecimals) ProtoMessage() {}

func (x *DenomDecimals) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DenomDecimals.ProtoReflect.Descriptor instead.
func (*DenomDecimals) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{47}
}

func (x *DenomDecimals) GetDenom() string {
	if x != nil {
		return x.Denom
	}
	return ""
}

func (x *DenomDecimals) GetDecimals() uint64 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

type GrantAuthorization struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Grantee       string                 `protobuf:"bytes,1,opt,name=grantee,proto3" json:"grantee,omitempty"`
	Amount        string                 `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GrantAuthorization) Reset() {
	*x = GrantAuthorization{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GrantAuthorization) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GrantAuthorization) ProtoMessage() {}

func (x *GrantAuthorization) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GrantAuthorization.ProtoReflect.Descriptor instead.
func (*GrantAuthorization) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{48}
}

func (x *GrantAuthorization) GetGrantee() string {
	if x != nil {
		return x.Grantee
	}
	return ""
}

func (x *GrantAuthorization) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type ActiveGrant struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Granter       string                 `protobuf:"bytes,1,opt,name=granter,proto3" json:"granter,omitempty"`
	Amount        string                 `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ActiveGrant) Reset() {
	*x = ActiveGrant{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ActiveGrant) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ActiveGrant) ProtoMessage() {}

func (x *ActiveGrant) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ActiveGrant.ProtoReflect.Descriptor instead.
func (*ActiveGrant) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{49}
}

func (x *ActiveGrant) GetGranter() string {
	if x != nil {
		return x.Granter
	}
	return ""
}

func (x *ActiveGrant) GetAmount() string {
	if x != nil {
		return x.Amount
	}
	return ""
}

type EffectiveGrant struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Granter         string                 `protobuf:"bytes,1,opt,name=granter,proto3" json:"granter,omitempty"`
	NetGrantedStake string                 `protobuf:"bytes,2,opt,name=net_granted_stake,json=netGrantedStake,proto3" json:"net_granted_stake,omitempty"`
	IsValid         bool                   `protobuf:"varint,3,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *EffectiveGrant) Reset() {
	*x = EffectiveGrant{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EffectiveGrant) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EffectiveGrant) ProtoMessage() {}

func (x *EffectiveGrant) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EffectiveGrant.ProtoReflect.Descriptor instead.
func (*EffectiveGrant) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{50}
}

func (x *EffectiveGrant) GetGranter() string {
	if x != nil {
		return x.Granter
	}
	return ""
}

func (x *EffectiveGrant) GetNetGrantedStake() string {
	if x != nil {
		return x.NetGrantedStake
	}
	return ""
}

func (x *EffectiveGrant) GetIsValid() bool {
	if x != nil {
		return x.IsValid
	}
	return false
}

type DenomMinNotional struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the denom of the token
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// the minimum notional value for the token (in chain format)
	MinNotional   string `protobuf:"bytes,2,opt,name=min_notional,json=minNotional,proto3" json:"min_notional,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DenomMinNotional) Reset() {
	*x = DenomMinNotional{}
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DenomMinNotional) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DenomMinNotional) ProtoMessage() {}

func (x *DenomMinNotional) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v1beta1_exchange_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DenomMinNotional.ProtoReflect.Descriptor instead.
func (*DenomMinNotional) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP(), []int{51}
}

func (x *DenomMinNotional) GetDenom() string {
	if x != nil {
		return x.Denom
	}
	return ""
}

func (x *DenomMinNotional) GetMinNotional() string {
	if x != nil {
		return x.MinNotional
	}
	return ""
}

var File_injective_exchange_v1beta1_exchange_proto protoreflect.FileDescriptor

const file_injective_exchange_v1beta1_exchange_proto_rawDesc = "" +
	"\n" +
	")injective/exchange/v1beta1/exchange.proto\x12\x1ainjective.exchange.v1beta1\x1a\x14gogoproto/gogo.proto\x1a\x1ecosmos/base/v1beta1/coin.proto\x1a%injective/oracle/v1beta1/oracle.proto\x1a\x11amino/amino.proto\"\x89\x16\n" +
	"\x06Params\x12e\n" +
	"\x1fspot_market_instant_listing_fee\x18\x01 \x01(\v2\x19.cosmos.base.v1beta1.CoinB\x04\xc8\xde\x1f\x00R\x1bspotMarketInstantListingFee\x12q\n" +
	"%derivative_market_instant_listing_fee\x18\x02 \x01(\v2\x19.cosmos.base.v1beta1.CoinB\x04\xc8\xde\x1f\x00R!derivativeMarketInstantListingFee\x12a\n" +
	"\x1bdefault_spot_maker_fee_rate\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x17defaultSpotMakerFeeRate\x12a\n" +
	"\x1bdefault_spot_taker_fee_rate\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x17defaultSpotTakerFeeRate\x12m\n" +
	"!default_derivative_maker_fee_rate\x18\x05 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x1ddefaultDerivativeMakerFeeRate\x12m\n" +
	"!default_derivative_taker_fee_rate\x18\x06 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x1ddefaultDerivativeTakerFeeRate\x12d\n" +
	"\x1cdefault_initial_margin_ratio\x18\a \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x19defaultInitialMarginRatio\x12l\n" +
	" default_maintenance_margin_ratio\x18\b \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x1ddefaultMaintenanceMarginRatio\x128\n" +
	"\x18default_funding_interval\x18\t \x01(\x03R\x16defaultFundingInterval\x12)\n" +
	"\x10funding_multiple\x18\n" +
	" \x01(\x03R\x0ffundingMultiple\x12X\n" +
	"\x16relayer_fee_share_rate\x18\v \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13relayerFeeShareRate\x12i\n" +
	"\x1fdefault_hourly_funding_rate_cap\x18\f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x1bdefaultHourlyFundingRateCap\x12d\n" +
	"\x1cdefault_hourly_interest_rate\x18\r \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x19defaultHourlyInterestRate\x12D\n" +
	"\x1fmax_derivative_order_side_count\x18\x0e \x01(\rR\x1bmaxDerivativeOrderSideCount\x12s\n" +
	"'inj_reward_staked_requirement_threshold\x18\x0f \x01(\tB\x1d\xc8\xde\x1f\x00\xda\xde\x1f\x15cosmossdk.io/math.IntR#injRewardStakedRequirementThreshold\x12G\n" +
	" trading_rewards_vesting_duration\x18\x10 \x01(\x03R\x1dtradingRewardsVestingDuration\x12d\n" +
	"\x1cliquidator_reward_share_rate\x18\x11 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x19liquidatorRewardShareRate\x12x\n" +
	")binary_options_market_instant_listing_fee\x18\x12 \x01(\v2\x19.cosmos.base.v1beta1.CoinB\x04\xc8\xde\x1f\x00R$binaryOptionsMarketInstantListingFee\x12\x80\x01\n" +
	" atomic_market_order_access_level\x18\x13 \x01(\x0e28.injective.exchange.v1beta1.AtomicMarketOrderAccessLevelR\x1catomicMarketOrderAccessLevel\x12x\n" +
	"'spot_atomic_market_order_fee_multiplier\x18\x14 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\"spotAtomicMarketOrderFeeMultiplier\x12\x84\x01\n" +
	"-derivative_atomic_market_order_fee_multiplier\x18\x15 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR(derivativeAtomicMarketOrderFeeMultiplier\x12\x8b\x01\n" +
	"1binary_options_atomic_market_order_fee_multiplier\x18\x16 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR+binaryOptionsAtomicMarketOrderFeeMultiplier\x12^\n" +
	"\x19minimal_protocol_fee_rate\x18\x17 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x16minimalProtocolFeeRate\x12[\n" +
	"+is_instant_derivative_market_launch_enabled\x18\x18 \x01(\bR&isInstantDerivativeMarketLaunchEnabled\x12D\n" +
	"\x1fpost_only_mode_height_threshold\x18\x19 \x01(\x03R\x1bpostOnlyModeHeightThreshold\x12g\n" +
	"1margin_decrease_price_timestamp_threshold_seconds\x18\x1a \x01(\x03R,marginDecreasePriceTimestampThresholdSeconds\x12'\n" +
	"\x0fexchange_admins\x18\x1b \x03(\tR\x0eexchangeAdmins\x12L\n" +
	"\x13inj_auction_max_cap\x18\x1c \x01(\tB\x1d\xc8\xde\x1f\x00\xda\xde\x1f\x15cosmossdk.io/math.IntR\x10injAuctionMaxCap\x12*\n" +
	"\x11fixed_gas_enabled\x18\x1d \x01(\bR\x0ffixedGasEnabled:\x18\xe8\xa0\x1f\x01\x8a\xe7\xb0*\x0fexchange/Params\"\x84\x01\n" +
	"\x13MarketFeeMultiplier\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12J\n" +
	"\x0efee_multiplier\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\rfeeMultiplier:\x04\x88\xa0\x1f\x00\"\xe8\t\n" +
	"\x10DerivativeMarket\x12\x16\n" +
	"\x06ticker\x18\x01 \x01(\tR\x06ticker\x12\x1f\n" +
	"\voracle_base\x18\x02 \x01(\tR\n" +
	"oracleBase\x12!\n" +
	"\foracle_quote\x18\x03 \x01(\tR\voracleQuote\x12E\n" +
	"\voracle_type\x18\x04 \x01(\x0e2$.injective.oracle.v1beta1.OracleTypeR\n" +
	"oracleType\x12.\n" +
	"\x13oracle_scale_factor\x18\x05 \x01(\rR\x11oracleScaleFactor\x12\x1f\n" +
	"\vquote_denom\x18\x06 \x01(\tR\n" +
	"quoteDenom\x12\x1b\n" +
	"\tmarket_id\x18\a \x01(\tR\bmarketId\x12U\n" +
	"\x14initial_margin_ratio\x18\b \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x12initialMarginRatio\x12]\n" +
	"\x18maintenance_margin_ratio\x18\t \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x16maintenanceMarginRatio\x12I\n" +
	"\x0emaker_fee_rate\x18\n" +
	" \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\fmakerFeeRate\x12I\n" +
	"\x0etaker_fee_rate\x18\v \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftakerFeeRate\x12X\n" +
	"\x16relayer_fee_share_rate\x18\f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13relayerFeeShareRate\x12 \n" +
	"\visPerpetual\x18\r \x01(\bR\visPerpetual\x12@\n" +
	"\x06status\x18\x0e \x01(\x0e2(.injective.exchange.v1beta1.MarketStatusR\x06status\x12R\n" +
	"\x13min_price_tick_size\x18\x0f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x10minPriceTickSize\x12X\n" +
	"\x16min_quantity_tick_size\x18\x10 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13minQuantityTickSize\x12F\n" +
	"\fmin_notional\x18\x11 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vminNotional\x12\x14\n" +
	"\x05admin\x18\x12 \x01(\tR\x05admin\x12+\n" +
	"\x11admin_permissions\x18\x13 \x01(\rR\x10adminPermissions\x12%\n" +
	"\x0equote_decimals\x18\x14 \x01(\rR\rquoteDecimals\x12S\n" +
	"\x13reduce_margin_ratio\x18\x15 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x11reduceMarginRatio:\x04\x88\xa0\x1f\x00\"\xfe\b\n" +
	"\x13BinaryOptionsMarket\x12\x16\n" +
	"\x06ticker\x18\x01 \x01(\tR\x06ticker\x12#\n" +
	"\roracle_symbol\x18\x02 \x01(\tR\foracleSymbol\x12'\n" +
	"\x0foracle_provider\x18\x03 \x01(\tR\x0eoracleProvider\x12E\n" +
	"\voracle_type\x18\x04 \x01(\x0e2$.injective.oracle.v1beta1.OracleTypeR\n" +
	"oracleType\x12.\n" +
	"\x13oracle_scale_factor\x18\x05 \x01(\rR\x11oracleScaleFactor\x121\n" +
	"\x14expiration_timestamp\x18\x06 \x01(\x03R\x13expirationTimestamp\x121\n" +
	"\x14settlement_timestamp\x18\a \x01(\x03R\x13settlementTimestamp\x12\x14\n" +
	"\x05admin\x18\b \x01(\tR\x05admin\x12\x1f\n" +
	"\vquote_denom\x18\t \x01(\tR\n" +
	"quoteDenom\x12\x1b\n" +
	"\tmarket_id\x18\n" +
	" \x01(\tR\bmarketId\x12I\n" +
	"\x0emaker_fee_rate\x18\v \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\fmakerFeeRate\x12I\n" +
	"\x0etaker_fee_rate\x18\f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftakerFeeRate\x12X\n" +
	"\x16relayer_fee_share_rate\x18\r \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13relayerFeeShareRate\x12@\n" +
	"\x06status\x18\x0e \x01(\x0e2(.injective.exchange.v1beta1.MarketStatusR\x06status\x12R\n" +
	"\x13min_price_tick_size\x18\x0f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x10minPriceTickSize\x12X\n" +
	"\x16min_quantity_tick_size\x18\x10 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13minQuantityTickSize\x12N\n" +
	"\x10settlement_price\x18\x11 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fsettlementPrice\x12F\n" +
	"\fmin_notional\x18\x12 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vminNotional\x12+\n" +
	"\x11admin_permissions\x18\x13 \x01(\rR\x10adminPermissions\x12%\n" +
	"\x0equote_decimals\x18\x14 \x01(\rR\rquoteDecimals:\x04\x88\xa0\x1f\x00\"\xe4\x02\n" +
	"\x17ExpiryFuturesMarketInfo\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x121\n" +
	"\x14expiration_timestamp\x18\x02 \x01(\x03R\x13expirationTimestamp\x120\n" +
	"\x14twap_start_timestamp\x18\x03 \x01(\x03R\x12twapStartTimestamp\x12w\n" +
	"&expiration_twap_start_price_cumulative\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\"expirationTwapStartPriceCumulative\x12N\n" +
	"\x10settlement_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fsettlementPrice\"\xc6\x02\n" +
	"\x13PerpetualMarketInfo\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12Z\n" +
	"\x17hourly_funding_rate_cap\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x14hourlyFundingRateCap\x12U\n" +
	"\x14hourly_interest_rate\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x12hourlyInterestRate\x124\n" +
	"\x16next_funding_timestamp\x18\x04 \x01(\x03R\x14nextFundingTimestamp\x12)\n" +
	"\x10funding_interval\x18\x05 \x01(\x03R\x0ffundingInterval\"\xe3\x01\n" +
	"\x16PerpetualMarketFunding\x12R\n" +
	"\x12cumulative_funding\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x11cumulativeFunding\x12N\n" +
	"\x10cumulative_price\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fcumulativePrice\x12%\n" +
	"\x0elast_timestamp\x18\x03 \x01(\x03R\rlastTimestamp\"\x8d\x01\n" +
	"\x1eDerivativeMarketSettlementInfo\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12N\n" +
	"\x10settlement_price\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fsettlementPrice\"=\n" +
	"\x14NextFundingTimestamp\x12%\n" +
	"\x0enext_timestamp\x18\x01 \x01(\x03R\rnextTimestamp\"\xea\x01\n" +
	"\x0eMidPriceAndTOB\x12@\n" +
	"\tmid_price\x18\x01 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bmidPrice\x12I\n" +
	"\x0ebest_buy_price\x18\x02 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\fbestBuyPrice\x12K\n" +
	"\x0fbest_sell_price\x18\x03 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\rbestSellPrice\"\xb8\x06\n" +
	"\n" +
	"SpotMarket\x12\x16\n" +
	"\x06ticker\x18\x01 \x01(\tR\x06ticker\x12\x1d\n" +
	"\n" +
	"base_denom\x18\x02 \x01(\tR\tbaseDenom\x12\x1f\n" +
	"\vquote_denom\x18\x03 \x01(\tR\n" +
	"quoteDenom\x12I\n" +
	"\x0emaker_fee_rate\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\fmakerFeeRate\x12I\n" +
	"\x0etaker_fee_rate\x18\x05 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftakerFeeRate\x12X\n" +
	"\x16relayer_fee_share_rate\x18\x06 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13relayerFeeShareRate\x12\x1b\n" +
	"\tmarket_id\x18\a \x01(\tR\bmarketId\x12@\n" +
	"\x06status\x18\b \x01(\x0e2(.injective.exchange.v1beta1.MarketStatusR\x06status\x12R\n" +
	"\x13min_price_tick_size\x18\t \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x10minPriceTickSize\x12X\n" +
	"\x16min_quantity_tick_size\x18\n" +
	" \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13minQuantityTickSize\x12F\n" +
	"\fmin_notional\x18\v \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vminNotional\x12\x14\n" +
	"\x05admin\x18\f \x01(\tR\x05admin\x12+\n" +
	"\x11admin_permissions\x18\r \x01(\rR\x10adminPermissions\x12#\n" +
	"\rbase_decimals\x18\x0e \x01(\rR\fbaseDecimals\x12%\n" +
	"\x0equote_decimals\x18\x0f \x01(\rR\rquoteDecimals\"\xa5\x01\n" +
	"\aDeposit\x12P\n" +
	"\x11available_balance\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x10availableBalance\x12H\n" +
	"\rtotal_balance\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftotalBalance\",\n" +
	"\x14SubaccountTradeNonce\x12\x14\n" +
	"\x05nonce\x18\x01 \x01(\rR\x05nonce\"\xe3\x01\n" +
	"\tOrderInfo\x12#\n" +
	"\rsubaccount_id\x18\x01 \x01(\tR\fsubaccountId\x12#\n" +
	"\rfee_recipient\x18\x02 \x01(\tR\ffeeRecipient\x129\n" +
	"\x05price\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x05price\x12?\n" +
	"\bquantity\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bquantity\x12\x10\n" +
	"\x03cid\x18\x05 \x01(\tR\x03cid\"\x84\x02\n" +
	"\tSpotOrder\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12J\n" +
	"\n" +
	"order_info\x18\x02 \x01(\v2%.injective.exchange.v1beta1.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12D\n" +
	"\n" +
	"order_type\x18\x03 \x01(\x0e2%.injective.exchange.v1beta1.OrderTypeR\torderType\x12H\n" +
	"\rtrigger_price\x18\x04 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\"\xcc\x02\n" +
	"\x0eSpotLimitOrder\x12J\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2%.injective.exchange.v1beta1.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12D\n" +
	"\n" +
	"order_type\x18\x02 \x01(\x0e2%.injective.exchange.v1beta1.OrderTypeR\torderType\x12?\n" +
	"\bfillable\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bfillable\x12H\n" +
	"\rtrigger_price\x18\x04 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x05 \x01(\fR\torderHash\"\xd4\x02\n" +
	"\x0fSpotMarketOrder\x12J\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2%.injective.exchange.v1beta1.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12F\n" +
	"\fbalance_hold\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vbalanceHold\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x03 \x01(\fR\torderHash\x12D\n" +
	"\n" +
	"order_type\x18\x04 \x01(\x0e2%.injective.exchange.v1beta1.OrderTypeR\torderType\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\"\xc7\x02\n" +
	"\x0fDerivativeOrder\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12J\n" +
	"\n" +
	"order_info\x18\x02 \x01(\v2%.injective.exchange.v1beta1.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12D\n" +
	"\n" +
	"order_type\x18\x03 \x01(\x0e2%.injective.exchange.v1beta1.OrderTypeR\torderType\x12;\n" +
	"\x06margin\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06margin\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\"\xfc\x03\n" +
	"\x1bSubaccountOrderbookMetadata\x129\n" +
	"\x19vanilla_limit_order_count\x18\x01 \x01(\rR\x16vanillaLimitOrderCount\x12@\n" +
	"\x1dreduce_only_limit_order_count\x18\x02 \x01(\rR\x19reduceOnlyLimitOrderCount\x12h\n" +
	"\x1eaggregate_reduce_only_quantity\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x1baggregateReduceOnlyQuantity\x12a\n" +
	"\x1aaggregate_vanilla_quantity\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x18aggregateVanillaQuantity\x12E\n" +
	"\x1fvanilla_conditional_order_count\x18\x05 \x01(\rR\x1cvanillaConditionalOrderCount\x12L\n" +
	"#reduce_only_conditional_order_count\x18\x06 \x01(\rR\x1freduceOnlyConditionalOrderCount\"\xc3\x01\n" +
	"\x0fSubaccountOrder\x129\n" +
	"\x05price\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x05price\x12?\n" +
	"\bquantity\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bquantity\x12\"\n" +
	"\fisReduceOnly\x18\x03 \x01(\bR\fisReduceOnly\x12\x10\n" +
	"\x03cid\x18\x04 \x01(\tR\x03cid\"w\n" +
	"\x13SubaccountOrderData\x12A\n" +
	"\x05order\x18\x01 \x01(\v2+.injective.exchange.v1beta1.SubaccountOrderR\x05order\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x02 \x01(\fR\torderHash\"\x8f\x03\n" +
	"\x14DerivativeLimitOrder\x12J\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2%.injective.exchange.v1beta1.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12D\n" +
	"\n" +
	"order_type\x18\x02 \x01(\x0e2%.injective.exchange.v1beta1.OrderTypeR\torderType\x12;\n" +
	"\x06margin\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06margin\x12?\n" +
	"\bfillable\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bfillable\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x06 \x01(\fR\torderHash\"\x95\x03\n" +
	"\x15DerivativeMarketOrder\x12J\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2%.injective.exchange.v1beta1.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12D\n" +
	"\n" +
	"order_type\x18\x02 \x01(\x0e2%.injective.exchange.v1beta1.OrderTypeR\torderType\x12;\n" +
	"\x06margin\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06margin\x12D\n" +
	"\vmargin_hold\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\n" +
	"marginHold\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x06 \x01(\fR\torderHash\"\xc5\x02\n" +
	"\bPosition\x12\x16\n" +
	"\x06isLong\x18\x01 \x01(\bR\x06isLong\x12?\n" +
	"\bquantity\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bquantity\x12D\n" +
	"\ventry_price\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\n" +
	"entryPrice\x12;\n" +
	"\x06margin\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06margin\x12]\n" +
	"\x18cumulative_funding_entry\x18\x05 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x16cumulativeFundingEntry\"I\n" +
	"\x14MarketOrderIndicator\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12\x14\n" +
	"\x05isBuy\x18\x02 \x01(\bR\x05isBuy\"\xcd\x02\n" +
	"\bTradeLog\x12?\n" +
	"\bquantity\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bquantity\x129\n" +
	"\x05price\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x05price\x12#\n" +
	"\rsubaccount_id\x18\x03 \x01(\fR\fsubaccountId\x125\n" +
	"\x03fee\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x03fee\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x05 \x01(\fR\torderHash\x128\n" +
	"\x15fee_recipient_address\x18\x06 \x01(\fB\x04\xc8\xde\x1f\x01R\x13feeRecipientAddress\x12\x10\n" +
	"\x03cid\x18\a \x01(\tR\x03cid\"\x9a\x02\n" +
	"\rPositionDelta\x12\x17\n" +
	"\ais_long\x18\x01 \x01(\bR\x06isLong\x12R\n" +
	"\x12execution_quantity\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x11executionQuantity\x12N\n" +
	"\x10execution_margin\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fexecutionMargin\x12L\n" +
	"\x0fexecution_price\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0eexecutionPrice\"\xa1\x03\n" +
	"\x12DerivativeTradeLog\x12#\n" +
	"\rsubaccount_id\x18\x01 \x01(\fR\fsubaccountId\x12P\n" +
	"\x0eposition_delta\x18\x02 \x01(\v2).injective.exchange.v1beta1.PositionDeltaR\rpositionDelta\x12;\n" +
	"\x06payout\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06payout\x125\n" +
	"\x03fee\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x03fee\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x05 \x01(\fR\torderHash\x128\n" +
	"\x15fee_recipient_address\x18\x06 \x01(\fB\x04\xc8\xde\x1f\x01R\x13feeRecipientAddress\x12\x10\n" +
	"\x03cid\x18\a \x01(\tR\x03cid\x125\n" +
	"\x03pnl\x18\b \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x03pnl\"{\n" +
	"\x12SubaccountPosition\x12@\n" +
	"\bposition\x18\x01 \x01(\v2$.injective.exchange.v1beta1.PositionR\bposition\x12#\n" +
	"\rsubaccount_id\x18\x02 \x01(\fR\fsubaccountId\"w\n" +
	"\x11SubaccountDeposit\x12#\n" +
	"\rsubaccount_id\x18\x01 \x01(\fR\fsubaccountId\x12=\n" +
	"\adeposit\x18\x02 \x01(\v2#.injective.exchange.v1beta1.DepositR\adeposit\"p\n" +
	"\rDepositUpdate\x12\x14\n" +
	"\x05denom\x18\x01 \x01(\tR\x05denom\x12I\n" +
	"\bdeposits\x18\x02 \x03(\v2-.injective.exchange.v1beta1.SubaccountDepositR\bdeposits\"\xcc\x01\n" +
	"\x10PointsMultiplier\x12[\n" +
	"\x17maker_points_multiplier\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x15makerPointsMultiplier\x12[\n" +
	"\x17taker_points_multiplier\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x15takerPointsMultiplier\"\xfe\x02\n" +
	"\x1eTradingRewardCampaignBoostInfo\x125\n" +
	"\x17boosted_spot_market_ids\x18\x01 \x03(\tR\x14boostedSpotMarketIds\x12j\n" +
	"\x17spot_market_multipliers\x18\x02 \x03(\v2,.injective.exchange.v1beta1.PointsMultiplierB\x04\xc8\xde\x1f\x00R\x15spotMarketMultipliers\x12A\n" +
	"\x1dboosted_derivative_market_ids\x18\x03 \x03(\tR\x1aboostedDerivativeMarketIds\x12v\n" +
	"\x1dderivative_market_multipliers\x18\x04 \x03(\v2,.injective.exchange.v1beta1.PointsMultiplierB\x04\xc8\xde\x1f\x00R\x1bderivativeMarketMultipliers\"\xbc\x01\n" +
	"\x12CampaignRewardPool\x12'\n" +
	"\x0fstart_timestamp\x18\x01 \x01(\x03R\x0estartTimestamp\x12}\n" +
	"\x14max_campaign_rewards\x18\x02 \x03(\v2\x19.cosmos.base.v1beta1.CoinB0\xc8\xde\x1f\x00\xaa\xdf\x1f(github.com/cosmos/cosmos-sdk/types.CoinsR\x12maxCampaignRewards\"\xa9\x02\n" +
	"\x19TradingRewardCampaignInfo\x12:\n" +
	"\x19campaign_duration_seconds\x18\x01 \x01(\x03R\x17campaignDurationSeconds\x12!\n" +
	"\fquote_denoms\x18\x02 \x03(\tR\vquoteDenoms\x12u\n" +
	"\x19trading_reward_boost_info\x18\x03 \x01(\v2:.injective.exchange.v1beta1.TradingRewardCampaignBoostInfoR\x16tradingRewardBoostInfo\x126\n" +
	"\x17disqualified_market_ids\x18\x04 \x03(\tR\x15disqualifiedMarketIds\"\xc0\x02\n" +
	"\x13FeeDiscountTierInfo\x12S\n" +
	"\x13maker_discount_rate\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x11makerDiscountRate\x12S\n" +
	"\x13taker_discount_rate\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x11takerDiscountRate\x12B\n" +
	"\rstaked_amount\x18\x03 \x01(\tB\x1d\xc8\xde\x1f\x00\xda\xde\x1f\x15cosmossdk.io/math.IntR\fstakedAmount\x12;\n" +
	"\x06volume\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06volume\"\x8c\x02\n" +
	"\x13FeeDiscountSchedule\x12!\n" +
	"\fbucket_count\x18\x01 \x01(\x04R\vbucketCount\x12'\n" +
	"\x0fbucket_duration\x18\x02 \x01(\x03R\x0ebucketDuration\x12!\n" +
	"\fquote_denoms\x18\x03 \x03(\tR\vquoteDenoms\x12N\n" +
	"\n" +
	"tier_infos\x18\x04 \x03(\v2/.injective.exchange.v1beta1.FeeDiscountTierInfoR\ttierInfos\x126\n" +
	"\x17disqualified_market_ids\x18\x05 \x03(\tR\x15disqualifiedMarketIds\"M\n" +
	"\x12FeeDiscountTierTTL\x12\x12\n" +
	"\x04tier\x18\x01 \x01(\x04R\x04tier\x12#\n" +
	"\rttl_timestamp\x18\x02 \x01(\x03R\fttlTimestamp\"\x9e\x01\n" +
	"\fVolumeRecord\x12F\n" +
	"\fmaker_volume\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vmakerVolume\x12F\n" +
	"\ftaker_volume\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vtakerVolume\"\x91\x01\n" +
	"\x0eAccountRewards\x12\x18\n" +
	"\aaccount\x18\x01 \x01(\tR\aaccount\x12e\n" +
	"\arewards\x18\x02 \x03(\v2\x19.cosmos.base.v1beta1.CoinB0\xc8\xde\x1f\x00\xaa\xdf\x1f(github.com/cosmos/cosmos-sdk/types.CoinsR\arewards\"\x86\x01\n" +
	"\fTradeRecords\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12Y\n" +
	"\x14latest_trade_records\x18\x02 \x03(\v2'.injective.exchange.v1beta1.TradeRecordR\x12latestTradeRecords\"6\n" +
	"\rSubaccountIDs\x12%\n" +
	"\x0esubaccount_ids\x18\x01 \x03(\fR\rsubaccountIds\"\xa7\x01\n" +
	"\vTradeRecord\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x03R\ttimestamp\x129\n" +
	"\x05price\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x05price\x12?\n" +
	"\bquantity\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bquantity\"m\n" +
	"\x05Level\x121\n" +
	"\x01p\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x01p\x121\n" +
	"\x01q\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x01q\"\x97\x01\n" +
	"\x1fAggregateSubaccountVolumeRecord\x12#\n" +
	"\rsubaccount_id\x18\x01 \x01(\tR\fsubaccountId\x12O\n" +
	"\x0emarket_volumes\x18\x02 \x03(\v2(.injective.exchange.v1beta1.MarketVolumeR\rmarketVolumes\"\x89\x01\n" +
	"\x1cAggregateAccountVolumeRecord\x12\x18\n" +
	"\aaccount\x18\x01 \x01(\tR\aaccount\x12O\n" +
	"\x0emarket_volumes\x18\x02 \x03(\v2(.injective.exchange.v1beta1.MarketVolumeR\rmarketVolumes\"s\n" +
	"\fMarketVolume\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12F\n" +
	"\x06volume\x18\x02 \x01(\v2(.injective.exchange.v1beta1.VolumeRecordB\x04\xc8\xde\x1f\x00R\x06volume\"A\n" +
	"\rDenomDecimals\x12\x14\n" +
	"\x05denom\x18\x01 \x01(\tR\x05denom\x12\x1a\n" +
	"\bdecimals\x18\x02 \x01(\x04R\bdecimals\"e\n" +
	"\x12GrantAuthorization\x12\x18\n" +
	"\agrantee\x18\x01 \x01(\tR\agrantee\x125\n" +
	"\x06amount\x18\x02 \x01(\tB\x1d\xc8\xde\x1f\x00\xda\xde\x1f\x15cosmossdk.io/math.IntR\x06amount\"^\n" +
	"\vActiveGrant\x12\x18\n" +
	"\agranter\x18\x01 \x01(\tR\agranter\x125\n" +
	"\x06amount\x18\x02 \x01(\tB\x1d\xc8\xde\x1f\x00\xda\xde\x1f\x15cosmossdk.io/math.IntR\x06amount\"\x90\x01\n" +
	"\x0eEffectiveGrant\x12\x18\n" +
	"\agranter\x18\x01 \x01(\tR\agranter\x12I\n" +
	"\x11net_granted_stake\x18\x02 \x01(\tB\x1d\xc8\xde\x1f\x00\xda\xde\x1f\x15cosmossdk.io/math.IntR\x0fnetGrantedStake\x12\x19\n" +
	"\bis_valid\x18\x03 \x01(\bR\aisValid\"p\n" +
	"\x10DenomMinNotional\x12\x14\n" +
	"\x05denom\x18\x01 \x01(\tR\x05denom\x12F\n" +
	"\fmin_notional\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vminNotional*t\n" +
	"\x1cAtomicMarketOrderAccessLevel\x12\n" +
	"\n" +
	"\x06Nobody\x10\x00\x12\"\n" +
	"\x1eBeginBlockerSmartContractsOnly\x10\x01\x12\x16\n" +
	"\x12SmartContractsOnly\x10\x02\x12\f\n" +
	"\bEveryone\x10\x03*T\n" +
	"\fMarketStatus\x12\x0f\n" +
	"\vUnspecified\x10\x00\x12\n" +
	"\n" +
	"\x06Active\x10\x01\x12\n" +
	"\n" +
	"\x06Paused\x10\x02\x12\x0e\n" +
	"\n" +
	"Demolished\x10\x03\x12\v\n" +
	"\aExpired\x10\x04*\xbb\x02\n" +
	"\tOrderType\x12 \n" +
	"\vUNSPECIFIED\x10\x00\x1a\x0f\x8a\x9d \vUNSPECIFIED\x12\x10\n" +
	"\x03BUY\x10\x01\x1a\a\x8a\x9d \x03BUY\x12\x12\n" +
	"\x04SELL\x10\x02\x1a\b\x8a\x9d \x04SELL\x12\x1a\n" +
	"\bSTOP_BUY\x10\x03\x1a\f\x8a\x9d \bSTOP_BUY\x12\x1c\n" +
	"\tSTOP_SELL\x10\x04\x1a\r\x8a\x9d \tSTOP_SELL\x12\x1a\n" +
	"\bTAKE_BUY\x10\x05\x1a\f\x8a\x9d \bTAKE_BUY\x12\x1c\n" +
	"\tTAKE_SELL\x10\x06\x1a\r\x8a\x9d \tTAKE_SELL\x12\x16\n" +
	"\x06BUY_PO\x10\a\x1a\n" +
	"\x8a\x9d \x06BUY_PO\x12\x18\n" +
	"\aSELL_PO\x10\b\x1a\v\x8a\x9d \aSELL_PO\x12\x1e\n" +
	"\n" +
	"BUY_ATOMIC\x10\t\x1a\x0e\x8a\x9d \n" +
	"BUY_ATOMIC\x12 \n" +
	"\vSELL_ATOMIC\x10\n" +
	"\x1a\x0f\x8a\x9d \vSELL_ATOMIC*\xaf\x01\n" +
	"\rExecutionType\x12\x1c\n" +
	"\x18UnspecifiedExecutionType\x10\x00\x12\n" +
	"\n" +
	"\x06Market\x10\x01\x12\r\n" +
	"\tLimitFill\x10\x02\x12\x1a\n" +
	"\x16LimitMatchRestingOrder\x10\x03\x12\x16\n" +
	"\x12LimitMatchNewOrder\x10\x04\x12\x15\n" +
	"\x11MarketLiquidation\x10\x05\x12\x1a\n" +
	"\x16ExpiryMarketSettlement\x10\x06*\x89\x02\n" +
	"\tOrderMask\x12\x16\n" +
	"\x06UNUSED\x10\x00\x1a\n" +
	"\x8a\x9d \x06UNUSED\x12\x10\n" +
	"\x03ANY\x10\x01\x1a\a\x8a\x9d \x03ANY\x12\x18\n" +
	"\aREGULAR\x10\x02\x1a\v\x8a\x9d \aREGULAR\x12 \n" +
	"\vCONDITIONAL\x10\x04\x1a\x0f\x8a\x9d \vCONDITIONAL\x12.\n" +
	"\x17DIRECTION_BUY_OR_HIGHER\x10\b\x1a\x11\x8a\x9d \rBUY_OR_HIGHER\x12.\n" +
	"\x17DIRECTION_SELL_OR_LOWER\x10\x10\x1a\x11\x8a\x9d \rSELL_OR_LOWER\x12\x1b\n" +
	"\vTYPE_MARKET\x10 \x1a\n" +
	"\x8a\x9d \x06MARKET\x12\x19\n" +
	"\n" +
	"TYPE_LIMIT\x10@\x1a\t\x8a\x9d \x05LIMITBPZNgithub.com/InjectiveLabs/injective-core/injective-chain/modules/exchange/typesb\x06proto3"

var (
	file_injective_exchange_v1beta1_exchange_proto_rawDescOnce sync.Once
	file_injective_exchange_v1beta1_exchange_proto_rawDescData []byte
)

func file_injective_exchange_v1beta1_exchange_proto_rawDescGZIP() []byte {
	file_injective_exchange_v1beta1_exchange_proto_rawDescOnce.Do(func() {
		file_injective_exchange_v1beta1_exchange_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_injective_exchange_v1beta1_exchange_proto_rawDesc), len(file_injective_exchange_v1beta1_exchange_proto_rawDesc)))
	})
	return file_injective_exchange_v1beta1_exchange_proto_rawDescData
}

var file_injective_exchange_v1beta1_exchange_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_injective_exchange_v1beta1_exchange_proto_msgTypes = make([]protoimpl.MessageInfo, 52)
var file_injective_exchange_v1beta1_exchange_proto_goTypes = []any{
	(AtomicMarketOrderAccessLevel)(0),       // 0: injective.exchange.v1beta1.AtomicMarketOrderAccessLevel
	(MarketStatus)(0),                       // 1: injective.exchange.v1beta1.MarketStatus
	(OrderType)(0),                          // 2: injective.exchange.v1beta1.OrderType
	(ExecutionType)(0),                      // 3: injective.exchange.v1beta1.ExecutionType
	(OrderMask)(0),                          // 4: injective.exchange.v1beta1.OrderMask
	(*Params)(nil),                          // 5: injective.exchange.v1beta1.Params
	(*MarketFeeMultiplier)(nil),             // 6: injective.exchange.v1beta1.MarketFeeMultiplier
	(*DerivativeMarket)(nil),                // 7: injective.exchange.v1beta1.DerivativeMarket
	(*BinaryOptionsMarket)(nil),             // 8: injective.exchange.v1beta1.BinaryOptionsMarket
	(*ExpiryFuturesMarketInfo)(nil),         // 9: injective.exchange.v1beta1.ExpiryFuturesMarketInfo
	(*PerpetualMarketInfo)(nil),             // 10: injective.exchange.v1beta1.PerpetualMarketInfo
	(*PerpetualMarketFunding)(nil),          // 11: injective.exchange.v1beta1.PerpetualMarketFunding
	(*DerivativeMarketSettlementInfo)(nil),  // 12: injective.exchange.v1beta1.DerivativeMarketSettlementInfo
	(*NextFundingTimestamp)(nil),            // 13: injective.exchange.v1beta1.NextFundingTimestamp
	(*MidPriceAndTOB)(nil),                  // 14: injective.exchange.v1beta1.MidPriceAndTOB
	(*SpotMarket)(nil),                      // 15: injective.exchange.v1beta1.SpotMarket
	(*Deposit)(nil),                         // 16: injective.exchange.v1beta1.Deposit
	(*SubaccountTradeNonce)(nil),            // 17: injective.exchange.v1beta1.SubaccountTradeNonce
	(*OrderInfo)(nil),                       // 18: injective.exchange.v1beta1.OrderInfo
	(*SpotOrder)(nil),                       // 19: injective.exchange.v1beta1.SpotOrder
	(*SpotLimitOrder)(nil),                  // 20: injective.exchange.v1beta1.SpotLimitOrder
	(*SpotMarketOrder)(nil),                 // 21: injective.exchange.v1beta1.SpotMarketOrder
	(*DerivativeOrder)(nil),                 // 22: injective.exchange.v1beta1.DerivativeOrder
	(*SubaccountOrderbookMetadata)(nil),     // 23: injective.exchange.v1beta1.SubaccountOrderbookMetadata
	(*SubaccountOrder)(nil),                 // 24: injective.exchange.v1beta1.SubaccountOrder
	(*SubaccountOrderData)(nil),             // 25: injective.exchange.v1beta1.SubaccountOrderData
	(*DerivativeLimitOrder)(nil),            // 26: injective.exchange.v1beta1.DerivativeLimitOrder
	(*DerivativeMarketOrder)(nil),           // 27: injective.exchange.v1beta1.DerivativeMarketOrder
	(*Position)(nil),                        // 28: injective.exchange.v1beta1.Position
	(*MarketOrderIndicator)(nil),            // 29: injective.exchange.v1beta1.MarketOrderIndicator
	(*TradeLog)(nil),                        // 30: injective.exchange.v1beta1.TradeLog
	(*PositionDelta)(nil),                   // 31: injective.exchange.v1beta1.PositionDelta
	(*DerivativeTradeLog)(nil),              // 32: injective.exchange.v1beta1.DerivativeTradeLog
	(*SubaccountPosition)(nil),              // 33: injective.exchange.v1beta1.SubaccountPosition
	(*SubaccountDeposit)(nil),               // 34: injective.exchange.v1beta1.SubaccountDeposit
	(*DepositUpdate)(nil),                   // 35: injective.exchange.v1beta1.DepositUpdate
	(*PointsMultiplier)(nil),                // 36: injective.exchange.v1beta1.PointsMultiplier
	(*TradingRewardCampaignBoostInfo)(nil),  // 37: injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
	(*CampaignRewardPool)(nil),              // 38: injective.exchange.v1beta1.CampaignRewardPool
	(*TradingRewardCampaignInfo)(nil),       // 39: injective.exchange.v1beta1.TradingRewardCampaignInfo
	(*FeeDiscountTierInfo)(nil),             // 40: injective.exchange.v1beta1.FeeDiscountTierInfo
	(*FeeDiscountSchedule)(nil),             // 41: injective.exchange.v1beta1.FeeDiscountSchedule
	(*FeeDiscountTierTTL)(nil),              // 42: injective.exchange.v1beta1.FeeDiscountTierTTL
	(*VolumeRecord)(nil),                    // 43: injective.exchange.v1beta1.VolumeRecord
	(*AccountRewards)(nil),                  // 44: injective.exchange.v1beta1.AccountRewards
	(*TradeRecords)(nil),                    // 45: injective.exchange.v1beta1.TradeRecords
	(*SubaccountIDs)(nil),                   // 46: injective.exchange.v1beta1.SubaccountIDs
	(*TradeRecord)(nil),                     // 47: injective.exchange.v1beta1.TradeRecord
	(*Level)(nil),                           // 48: injective.exchange.v1beta1.Level
	(*AggregateSubaccountVolumeRecord)(nil), // 49: injective.exchange.v1beta1.AggregateSubaccountVolumeRecord
	(*AggregateAccountVolumeRecord)(nil),    // 50: injective.exchange.v1beta1.AggregateAccountVolumeRecord
	(*MarketVolume)(nil),                    // 51: injective.exchange.v1beta1.MarketVolume
	(*DenomDecimals)(nil),                   // 52: injective.exchange.v1beta1.DenomDecimals
	(*GrantAuthorization)(nil),              // 53: injective.exchange.v1beta1.GrantAuthorization
	(*ActiveGrant)(nil),                     // 54: injective.exchange.v1beta1.ActiveGrant
	(*EffectiveGrant)(nil),                  // 55: injective.exchange.v1beta1.EffectiveGrant
	(*DenomMinNotional)(nil),                // 56: injective.exchange.v1beta1.DenomMinNotional
	(*types.Coin)(nil),                      // 57: cosmos.base.v1beta1.Coin
	(types1.OracleType)(0),                  // 58: injective.oracle.v1beta1.OracleType
}
var file_injective_exchange_v1beta1_exchange_proto_depIdxs = []int32{
	57, // 0: injective.exchange.v1beta1.Params.spot_market_instant_listing_fee:type_name -> cosmos.base.v1beta1.Coin
	57, // 1: injective.exchange.v1beta1.Params.derivative_market_instant_listing_fee:type_name -> cosmos.base.v1beta1.Coin
	57, // 2: injective.exchange.v1beta1.Params.binary_options_market_instant_listing_fee:type_name -> cosmos.base.v1beta1.Coin
	0,  // 3: injective.exchange.v1beta1.Params.atomic_market_order_access_level:type_name -> injective.exchange.v1beta1.AtomicMarketOrderAccessLevel
	58, // 4: injective.exchange.v1beta1.DerivativeMarket.oracle_type:type_name -> injective.oracle.v1beta1.OracleType
	1,  // 5: injective.exchange.v1beta1.DerivativeMarket.status:type_name -> injective.exchange.v1beta1.MarketStatus
	58, // 6: injective.exchange.v1beta1.BinaryOptionsMarket.oracle_type:type_name -> injective.oracle.v1beta1.OracleType
	1,  // 7: injective.exchange.v1beta1.BinaryOptionsMarket.status:type_name -> injective.exchange.v1beta1.MarketStatus
	1,  // 8: injective.exchange.v1beta1.SpotMarket.status:type_name -> injective.exchange.v1beta1.MarketStatus
	18, // 9: injective.exchange.v1beta1.SpotOrder.order_info:type_name -> injective.exchange.v1beta1.OrderInfo
	2,  // 10: injective.exchange.v1beta1.SpotOrder.order_type:type_name -> injective.exchange.v1beta1.OrderType
	18, // 11: injective.exchange.v1beta1.SpotLimitOrder.order_info:type_name -> injective.exchange.v1beta1.OrderInfo
	2,  // 12: injective.exchange.v1beta1.SpotLimitOrder.order_type:type_name -> injective.exchange.v1beta1.OrderType
	18, // 13: injective.exchange.v1beta1.SpotMarketOrder.order_info:type_name -> injective.exchange.v1beta1.OrderInfo
	2,  // 14: injective.exchange.v1beta1.SpotMarketOrder.order_type:type_name -> injective.exchange.v1beta1.OrderType
	18, // 15: injective.exchange.v1beta1.DerivativeOrder.order_info:type_name -> injective.exchange.v1beta1.OrderInfo
	2,  // 16: injective.exchange.v1beta1.DerivativeOrder.order_type:type_name -> injective.exchange.v1beta1.OrderType
	24, // 17: injective.exchange.v1beta1.SubaccountOrderData.order:type_name -> injective.exchange.v1beta1.SubaccountOrder
	18, // 18: injective.exchange.v1beta1.DerivativeLimitOrder.order_info:type_name -> injective.exchange.v1beta1.OrderInfo
	2,  // 19: injective.exchange.v1beta1.DerivativeLimitOrder.order_type:type_name -> injective.exchange.v1beta1.OrderType
	18, // 20: injective.exchange.v1beta1.DerivativeMarketOrder.order_info:type_name -> injective.exchange.v1beta1.OrderInfo
	2,  // 21: injective.exchange.v1beta1.DerivativeMarketOrder.order_type:type_name -> injective.exchange.v1beta1.OrderType
	31, // 22: injective.exchange.v1beta1.DerivativeTradeLog.position_delta:type_name -> injective.exchange.v1beta1.PositionDelta
	28, // 23: injective.exchange.v1beta1.SubaccountPosition.position:type_name -> injective.exchange.v1beta1.Position
	16, // 24: injective.exchange.v1beta1.SubaccountDeposit.deposit:type_name -> injective.exchange.v1beta1.Deposit
	34, // 25: injective.exchange.v1beta1.DepositUpdate.deposits:type_name -> injective.exchange.v1beta1.SubaccountDeposit
	36, // 26: injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.spot_market_multipliers:type_name -> injective.exchange.v1beta1.PointsMultiplier
	36, // 27: injective.exchange.v1beta1.TradingRewardCampaignBoostInfo.derivative_market_multipliers:type_name -> injective.exchange.v1beta1.PointsMultiplier
	57, // 28: injective.exchange.v1beta1.CampaignRewardPool.max_campaign_rewards:type_name -> cosmos.base.v1beta1.Coin
	37, // 29: injective.exchange.v1beta1.TradingRewardCampaignInfo.trading_reward_boost_info:type_name -> injective.exchange.v1beta1.TradingRewardCampaignBoostInfo
	40, // 30: injective.exchange.v1beta1.FeeDiscountSchedule.tier_infos:type_name -> injective.exchange.v1beta1.FeeDiscountTierInfo
	57, // 31: injective.exchange.v1beta1.AccountRewards.rewards:type_name -> cosmos.base.v1beta1.Coin
	47, // 32: injective.exchange.v1beta1.TradeRecords.latest_trade_records:type_name -> injective.exchange.v1beta1.TradeRecord
	51, // 33: injective.exchange.v1beta1.AggregateSubaccountVolumeRecord.market_volumes:type_name -> injective.exchange.v1beta1.MarketVolume
	51, // 34: injective.exchange.v1beta1.AggregateAccountVolumeRecord.market_volumes:type_name -> injective.exchange.v1beta1.MarketVolume
	43, // 35: injective.exchange.v1beta1.MarketVolume.volume:type_name -> injective.exchange.v1beta1.VolumeRecord
	36, // [36:36] is the sub-list for method output_type
	36, // [36:36] is the sub-list for method input_type
	36, // [36:36] is the sub-list for extension type_name
	36, // [36:36] is the sub-list for extension extendee
	0,  // [0:36] is the sub-list for field type_name
}

func init() { file_injective_exchange_v1beta1_exchange_proto_init() }
func file_injective_exchange_v1beta1_exchange_proto_init() {
	if File_injective_exchange_v1beta1_exchange_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_injective_exchange_v1beta1_exchange_proto_rawDesc), len(file_injective_exchange_v1beta1_exchange_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   52,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_injective_exchange_v1beta1_exchange_proto_goTypes,
		DependencyIndexes: file_injective_exchange_v1beta1_exchange_proto_depIdxs,
		EnumInfos:         file_injective_exchange_v1beta1_exchange_proto_enumTypes,
		MessageInfos:      file_injective_exchange_v1beta1_exchange_proto_msgTypes,
	}.Build()
	File_injective_exchange_v1beta1_exchange_proto = out.File
	file_injective_exchange_v1beta1_exchange_proto_goTypes = nil
	file_injective_exchange_v1beta1_exchange_proto_depIdxs = nil
}
