// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: injective/exchange/v1beta1/tx.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Msg_Deposit_FullMethodName                          = "/injective.exchange.v1beta1.Msg/Deposit"
	Msg_Withdraw_FullMethodName                         = "/injective.exchange.v1beta1.Msg/Withdraw"
	Msg_InstantSpotMarketLaunch_FullMethodName          = "/injective.exchange.v1beta1.Msg/InstantSpotMarketLaunch"
	Msg_CreateSpotLimitOrder_FullMethodName             = "/injective.exchange.v1beta1.Msg/CreateSpotLimitOrder"
	Msg_BatchCreateSpotLimitOrders_FullMethodName       = "/injective.exchange.v1beta1.Msg/BatchCreateSpotLimitOrders"
	Msg_CreateSpotMarketOrder_FullMethodName            = "/injective.exchange.v1beta1.Msg/CreateSpotMarketOrder"
	Msg_CancelSpotOrder_FullMethodName                  = "/injective.exchange.v1beta1.Msg/CancelSpotOrder"
	Msg_BatchCancelSpotOrders_FullMethodName            = "/injective.exchange.v1beta1.Msg/BatchCancelSpotOrders"
	Msg_BatchUpdateOrders_FullMethodName                = "/injective.exchange.v1beta1.Msg/BatchUpdateOrders"
	Msg_PrivilegedExecuteContract_FullMethodName        = "/injective.exchange.v1beta1.Msg/PrivilegedExecuteContract"
	Msg_CreateDerivativeLimitOrder_FullMethodName       = "/injective.exchange.v1beta1.Msg/CreateDerivativeLimitOrder"
	Msg_BatchCreateDerivativeLimitOrders_FullMethodName = "/injective.exchange.v1beta1.Msg/BatchCreateDerivativeLimitOrders"
	Msg_CreateDerivativeMarketOrder_FullMethodName      = "/injective.exchange.v1beta1.Msg/CreateDerivativeMarketOrder"
	Msg_CancelDerivativeOrder_FullMethodName            = "/injective.exchange.v1beta1.Msg/CancelDerivativeOrder"
	Msg_BatchCancelDerivativeOrders_FullMethodName      = "/injective.exchange.v1beta1.Msg/BatchCancelDerivativeOrders"
	Msg_InstantBinaryOptionsMarketLaunch_FullMethodName = "/injective.exchange.v1beta1.Msg/InstantBinaryOptionsMarketLaunch"
	Msg_CreateBinaryOptionsLimitOrder_FullMethodName    = "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsLimitOrder"
	Msg_CreateBinaryOptionsMarketOrder_FullMethodName   = "/injective.exchange.v1beta1.Msg/CreateBinaryOptionsMarketOrder"
	Msg_CancelBinaryOptionsOrder_FullMethodName         = "/injective.exchange.v1beta1.Msg/CancelBinaryOptionsOrder"
	Msg_BatchCancelBinaryOptionsOrders_FullMethodName   = "/injective.exchange.v1beta1.Msg/BatchCancelBinaryOptionsOrders"
	Msg_SubaccountTransfer_FullMethodName               = "/injective.exchange.v1beta1.Msg/SubaccountTransfer"
	Msg_ExternalTransfer_FullMethodName                 = "/injective.exchange.v1beta1.Msg/ExternalTransfer"
	Msg_LiquidatePosition_FullMethodName                = "/injective.exchange.v1beta1.Msg/LiquidatePosition"
	Msg_EmergencySettleMarket_FullMethodName            = "/injective.exchange.v1beta1.Msg/EmergencySettleMarket"
	Msg_IncreasePositionMargin_FullMethodName           = "/injective.exchange.v1beta1.Msg/IncreasePositionMargin"
	Msg_DecreasePositionMargin_FullMethodName           = "/injective.exchange.v1beta1.Msg/DecreasePositionMargin"
	Msg_RewardsOptOut_FullMethodName                    = "/injective.exchange.v1beta1.Msg/RewardsOptOut"
	Msg_AdminUpdateBinaryOptionsMarket_FullMethodName   = "/injective.exchange.v1beta1.Msg/AdminUpdateBinaryOptionsMarket"
	Msg_UpdateParams_FullMethodName                     = "/injective.exchange.v1beta1.Msg/UpdateParams"
	Msg_UpdateSpotMarket_FullMethodName                 = "/injective.exchange.v1beta1.Msg/UpdateSpotMarket"
	Msg_UpdateDerivativeMarket_FullMethodName           = "/injective.exchange.v1beta1.Msg/UpdateDerivativeMarket"
	Msg_AuthorizeStakeGrants_FullMethodName             = "/injective.exchange.v1beta1.Msg/AuthorizeStakeGrants"
	Msg_ActivateStakeGrant_FullMethodName               = "/injective.exchange.v1beta1.Msg/ActivateStakeGrant"
	Msg_BatchExchangeModification_FullMethodName        = "/injective.exchange.v1beta1.Msg/BatchExchangeModification"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Msg defines the exchange Msg service.
type MsgClient interface {
	// Deposit defines a method for transferring coins from the sender's bank
	// balance into the subaccount's exchange deposits
	Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error)
	// Withdraw defines a method for withdrawing coins from a subaccount's
	// deposits to the user's bank balance
	Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error)
	// InstantSpotMarketLaunch defines method for creating a spot market by paying
	// listing fee without governance
	InstantSpotMarketLaunch(ctx context.Context, in *MsgInstantSpotMarketLaunch, opts ...grpc.CallOption) (*MsgInstantSpotMarketLaunchResponse, error)
	// CreateSpotLimitOrder defines a method for creating a new spot limit order.
	CreateSpotLimitOrder(ctx context.Context, in *MsgCreateSpotLimitOrder, opts ...grpc.CallOption) (*MsgCreateSpotLimitOrderResponse, error)
	// BatchCreateSpotLimitOrder defines a method for creating a new batch of spot
	// limit orders.
	BatchCreateSpotLimitOrders(ctx context.Context, in *MsgBatchCreateSpotLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateSpotLimitOrdersResponse, error)
	// CreateSpotMarketOrder defines a method for creating a new spot market
	// order.
	CreateSpotMarketOrder(ctx context.Context, in *MsgCreateSpotMarketOrder, opts ...grpc.CallOption) (*MsgCreateSpotMarketOrderResponse, error)
	// MsgCancelSpotOrder defines a method for cancelling a spot order.
	CancelSpotOrder(ctx context.Context, in *MsgCancelSpotOrder, opts ...grpc.CallOption) (*MsgCancelSpotOrderResponse, error)
	// BatchCancelSpotOrders defines a method for cancelling a batch of spot
	// orders in a given market.
	BatchCancelSpotOrders(ctx context.Context, in *MsgBatchCancelSpotOrders, opts ...grpc.CallOption) (*MsgBatchCancelSpotOrdersResponse, error)
	// BatchUpdateOrders defines a method for updating a batch of orders.
	BatchUpdateOrders(ctx context.Context, in *MsgBatchUpdateOrders, opts ...grpc.CallOption) (*MsgBatchUpdateOrdersResponse, error)
	// PrivilegedExecuteContract defines a method for executing a Cosmwasm
	// contract from the exchange module with privileged capabilities.
	PrivilegedExecuteContract(ctx context.Context, in *MsgPrivilegedExecuteContract, opts ...grpc.CallOption) (*MsgPrivilegedExecuteContractResponse, error)
	// CreateDerivativeLimitOrder defines a method for creating a new derivative
	// limit order.
	CreateDerivativeLimitOrder(ctx context.Context, in *MsgCreateDerivativeLimitOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeLimitOrderResponse, error)
	// BatchCreateDerivativeLimitOrders defines a method for creating a new batch
	// of derivative limit orders.
	BatchCreateDerivativeLimitOrders(ctx context.Context, in *MsgBatchCreateDerivativeLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateDerivativeLimitOrdersResponse, error)
	// MsgCreateDerivativeLimitOrder defines a method for creating a new
	// derivative market order.
	CreateDerivativeMarketOrder(ctx context.Context, in *MsgCreateDerivativeMarketOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeMarketOrderResponse, error)
	// MsgCancelDerivativeOrder defines a method for cancelling a derivative
	// order.
	CancelDerivativeOrder(ctx context.Context, in *MsgCancelDerivativeOrder, opts ...grpc.CallOption) (*MsgCancelDerivativeOrderResponse, error)
	// MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of
	// derivative limit orders.
	BatchCancelDerivativeOrders(ctx context.Context, in *MsgBatchCancelDerivativeOrders, opts ...grpc.CallOption) (*MsgBatchCancelDerivativeOrdersResponse, error)
	// InstantBinaryOptionsMarketLaunch defines method for creating a binary
	// options market by paying listing fee without governance
	InstantBinaryOptionsMarketLaunch(ctx context.Context, in *MsgInstantBinaryOptionsMarketLaunch, opts ...grpc.CallOption) (*MsgInstantBinaryOptionsMarketLaunchResponse, error)
	// CreateBinaryOptionsLimitOrder defines a method for creating a new binary
	// options limit order.
	CreateBinaryOptionsLimitOrder(ctx context.Context, in *MsgCreateBinaryOptionsLimitOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsLimitOrderResponse, error)
	// CreateBinaryOptionsMarketOrder defines a method for creating a new binary
	// options market order.
	CreateBinaryOptionsMarketOrder(ctx context.Context, in *MsgCreateBinaryOptionsMarketOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsMarketOrderResponse, error)
	// MsgCancelBinaryOptionsOrder defines a method for cancelling a binary
	// options order.
	CancelBinaryOptionsOrder(ctx context.Context, in *MsgCancelBinaryOptionsOrder, opts ...grpc.CallOption) (*MsgCancelBinaryOptionsOrderResponse, error)
	// BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of
	// binary options limit orders.
	BatchCancelBinaryOptionsOrders(ctx context.Context, in *MsgBatchCancelBinaryOptionsOrders, opts ...grpc.CallOption) (*MsgBatchCancelBinaryOptionsOrdersResponse, error)
	// SubaccountTransfer defines a method for transfer between subaccounts
	SubaccountTransfer(ctx context.Context, in *MsgSubaccountTransfer, opts ...grpc.CallOption) (*MsgSubaccountTransferResponse, error)
	// ExternalTransfer defines a method for transfer between external accounts
	ExternalTransfer(ctx context.Context, in *MsgExternalTransfer, opts ...grpc.CallOption) (*MsgExternalTransferResponse, error)
	// LiquidatePosition defines a method for liquidating a position
	LiquidatePosition(ctx context.Context, in *MsgLiquidatePosition, opts ...grpc.CallOption) (*MsgLiquidatePositionResponse, error)
	// EmergencySettleMarket defines a method for emergency settling a market
	EmergencySettleMarket(ctx context.Context, in *MsgEmergencySettleMarket, opts ...grpc.CallOption) (*MsgEmergencySettleMarketResponse, error)
	// IncreasePositionMargin defines a method for increasing margin of a position
	IncreasePositionMargin(ctx context.Context, in *MsgIncreasePositionMargin, opts ...grpc.CallOption) (*MsgIncreasePositionMarginResponse, error)
	// DecreasePositionMargin defines a method for decreasing margin of a position
	DecreasePositionMargin(ctx context.Context, in *MsgDecreasePositionMargin, opts ...grpc.CallOption) (*MsgDecreasePositionMarginResponse, error)
	// RewardsOptOut defines a method for opting out of rewards
	RewardsOptOut(ctx context.Context, in *MsgRewardsOptOut, opts ...grpc.CallOption) (*MsgRewardsOptOutResponse, error)
	// AdminUpdateBinaryOptionsMarket defines method for updating a binary options
	// market by admin
	AdminUpdateBinaryOptionsMarket(ctx context.Context, in *MsgAdminUpdateBinaryOptionsMarket, opts ...grpc.CallOption) (*MsgAdminUpdateBinaryOptionsMarketResponse, error)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// UpdateSpotMarket modifies certain spot market fields (admin only)
	UpdateSpotMarket(ctx context.Context, in *MsgUpdateSpotMarket, opts ...grpc.CallOption) (*MsgUpdateSpotMarketResponse, error)
	// UpdateDerivativeMarket modifies certain derivative market fields (admin
	// only)
	UpdateDerivativeMarket(ctx context.Context, in *MsgUpdateDerivativeMarket, opts ...grpc.CallOption) (*MsgUpdateDerivativeMarketResponse, error)
	AuthorizeStakeGrants(ctx context.Context, in *MsgAuthorizeStakeGrants, opts ...grpc.CallOption) (*MsgAuthorizeStakeGrantsResponse, error)
	ActivateStakeGrant(ctx context.Context, in *MsgActivateStakeGrant, opts ...grpc.CallOption) (*MsgActivateStakeGrantResponse, error)
	BatchExchangeModification(ctx context.Context, in *MsgBatchExchangeModification, opts ...grpc.CallOption) (*MsgBatchExchangeModificationResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Deposit(ctx context.Context, in *MsgDeposit, opts ...grpc.CallOption) (*MsgDepositResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgDepositResponse)
	err := c.cc.Invoke(ctx, Msg_Deposit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Withdraw(ctx context.Context, in *MsgWithdraw, opts ...grpc.CallOption) (*MsgWithdrawResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgWithdrawResponse)
	err := c.cc.Invoke(ctx, Msg_Withdraw_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantSpotMarketLaunch(ctx context.Context, in *MsgInstantSpotMarketLaunch, opts ...grpc.CallOption) (*MsgInstantSpotMarketLaunchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgInstantSpotMarketLaunchResponse)
	err := c.cc.Invoke(ctx, Msg_InstantSpotMarketLaunch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSpotLimitOrder(ctx context.Context, in *MsgCreateSpotLimitOrder, opts ...grpc.CallOption) (*MsgCreateSpotLimitOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateSpotLimitOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CreateSpotLimitOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCreateSpotLimitOrders(ctx context.Context, in *MsgBatchCreateSpotLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateSpotLimitOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBatchCreateSpotLimitOrdersResponse)
	err := c.cc.Invoke(ctx, Msg_BatchCreateSpotLimitOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateSpotMarketOrder(ctx context.Context, in *MsgCreateSpotMarketOrder, opts ...grpc.CallOption) (*MsgCreateSpotMarketOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateSpotMarketOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CreateSpotMarketOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelSpotOrder(ctx context.Context, in *MsgCancelSpotOrder, opts ...grpc.CallOption) (*MsgCancelSpotOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCancelSpotOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CancelSpotOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelSpotOrders(ctx context.Context, in *MsgBatchCancelSpotOrders, opts ...grpc.CallOption) (*MsgBatchCancelSpotOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBatchCancelSpotOrdersResponse)
	err := c.cc.Invoke(ctx, Msg_BatchCancelSpotOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchUpdateOrders(ctx context.Context, in *MsgBatchUpdateOrders, opts ...grpc.CallOption) (*MsgBatchUpdateOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBatchUpdateOrdersResponse)
	err := c.cc.Invoke(ctx, Msg_BatchUpdateOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PrivilegedExecuteContract(ctx context.Context, in *MsgPrivilegedExecuteContract, opts ...grpc.CallOption) (*MsgPrivilegedExecuteContractResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgPrivilegedExecuteContractResponse)
	err := c.cc.Invoke(ctx, Msg_PrivilegedExecuteContract_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDerivativeLimitOrder(ctx context.Context, in *MsgCreateDerivativeLimitOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeLimitOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateDerivativeLimitOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CreateDerivativeLimitOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCreateDerivativeLimitOrders(ctx context.Context, in *MsgBatchCreateDerivativeLimitOrders, opts ...grpc.CallOption) (*MsgBatchCreateDerivativeLimitOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBatchCreateDerivativeLimitOrdersResponse)
	err := c.cc.Invoke(ctx, Msg_BatchCreateDerivativeLimitOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateDerivativeMarketOrder(ctx context.Context, in *MsgCreateDerivativeMarketOrder, opts ...grpc.CallOption) (*MsgCreateDerivativeMarketOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateDerivativeMarketOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CreateDerivativeMarketOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelDerivativeOrder(ctx context.Context, in *MsgCancelDerivativeOrder, opts ...grpc.CallOption) (*MsgCancelDerivativeOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCancelDerivativeOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CancelDerivativeOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelDerivativeOrders(ctx context.Context, in *MsgBatchCancelDerivativeOrders, opts ...grpc.CallOption) (*MsgBatchCancelDerivativeOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBatchCancelDerivativeOrdersResponse)
	err := c.cc.Invoke(ctx, Msg_BatchCancelDerivativeOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InstantBinaryOptionsMarketLaunch(ctx context.Context, in *MsgInstantBinaryOptionsMarketLaunch, opts ...grpc.CallOption) (*MsgInstantBinaryOptionsMarketLaunchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgInstantBinaryOptionsMarketLaunchResponse)
	err := c.cc.Invoke(ctx, Msg_InstantBinaryOptionsMarketLaunch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBinaryOptionsLimitOrder(ctx context.Context, in *MsgCreateBinaryOptionsLimitOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsLimitOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateBinaryOptionsLimitOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CreateBinaryOptionsLimitOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateBinaryOptionsMarketOrder(ctx context.Context, in *MsgCreateBinaryOptionsMarketOrder, opts ...grpc.CallOption) (*MsgCreateBinaryOptionsMarketOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCreateBinaryOptionsMarketOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CreateBinaryOptionsMarketOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelBinaryOptionsOrder(ctx context.Context, in *MsgCancelBinaryOptionsOrder, opts ...grpc.CallOption) (*MsgCancelBinaryOptionsOrderResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgCancelBinaryOptionsOrderResponse)
	err := c.cc.Invoke(ctx, Msg_CancelBinaryOptionsOrder_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchCancelBinaryOptionsOrders(ctx context.Context, in *MsgBatchCancelBinaryOptionsOrders, opts ...grpc.CallOption) (*MsgBatchCancelBinaryOptionsOrdersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBatchCancelBinaryOptionsOrdersResponse)
	err := c.cc.Invoke(ctx, Msg_BatchCancelBinaryOptionsOrders_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubaccountTransfer(ctx context.Context, in *MsgSubaccountTransfer, opts ...grpc.CallOption) (*MsgSubaccountTransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgSubaccountTransferResponse)
	err := c.cc.Invoke(ctx, Msg_SubaccountTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ExternalTransfer(ctx context.Context, in *MsgExternalTransfer, opts ...grpc.CallOption) (*MsgExternalTransferResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgExternalTransferResponse)
	err := c.cc.Invoke(ctx, Msg_ExternalTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) LiquidatePosition(ctx context.Context, in *MsgLiquidatePosition, opts ...grpc.CallOption) (*MsgLiquidatePositionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgLiquidatePositionResponse)
	err := c.cc.Invoke(ctx, Msg_LiquidatePosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) EmergencySettleMarket(ctx context.Context, in *MsgEmergencySettleMarket, opts ...grpc.CallOption) (*MsgEmergencySettleMarketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgEmergencySettleMarketResponse)
	err := c.cc.Invoke(ctx, Msg_EmergencySettleMarket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IncreasePositionMargin(ctx context.Context, in *MsgIncreasePositionMargin, opts ...grpc.CallOption) (*MsgIncreasePositionMarginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgIncreasePositionMarginResponse)
	err := c.cc.Invoke(ctx, Msg_IncreasePositionMargin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DecreasePositionMargin(ctx context.Context, in *MsgDecreasePositionMargin, opts ...grpc.CallOption) (*MsgDecreasePositionMarginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgDecreasePositionMarginResponse)
	err := c.cc.Invoke(ctx, Msg_DecreasePositionMargin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RewardsOptOut(ctx context.Context, in *MsgRewardsOptOut, opts ...grpc.CallOption) (*MsgRewardsOptOutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRewardsOptOutResponse)
	err := c.cc.Invoke(ctx, Msg_RewardsOptOut_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AdminUpdateBinaryOptionsMarket(ctx context.Context, in *MsgAdminUpdateBinaryOptionsMarket, opts ...grpc.CallOption) (*MsgAdminUpdateBinaryOptionsMarketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAdminUpdateBinaryOptionsMarketResponse)
	err := c.cc.Invoke(ctx, Msg_AdminUpdateBinaryOptionsMarket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateSpotMarket(ctx context.Context, in *MsgUpdateSpotMarket, opts ...grpc.CallOption) (*MsgUpdateSpotMarketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateSpotMarketResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateSpotMarket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDerivativeMarket(ctx context.Context, in *MsgUpdateDerivativeMarket, opts ...grpc.CallOption) (*MsgUpdateDerivativeMarketResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateDerivativeMarketResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateDerivativeMarket_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AuthorizeStakeGrants(ctx context.Context, in *MsgAuthorizeStakeGrants, opts ...grpc.CallOption) (*MsgAuthorizeStakeGrantsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAuthorizeStakeGrantsResponse)
	err := c.cc.Invoke(ctx, Msg_AuthorizeStakeGrants_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ActivateStakeGrant(ctx context.Context, in *MsgActivateStakeGrant, opts ...grpc.CallOption) (*MsgActivateStakeGrantResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgActivateStakeGrantResponse)
	err := c.cc.Invoke(ctx, Msg_ActivateStakeGrant_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BatchExchangeModification(ctx context.Context, in *MsgBatchExchangeModification, opts ...grpc.CallOption) (*MsgBatchExchangeModificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgBatchExchangeModificationResponse)
	err := c.cc.Invoke(ctx, Msg_BatchExchangeModification_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility.
//
// Msg defines the exchange Msg service.
type MsgServer interface {
	// Deposit defines a method for transferring coins from the sender's bank
	// balance into the subaccount's exchange deposits
	Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error)
	// Withdraw defines a method for withdrawing coins from a subaccount's
	// deposits to the user's bank balance
	Withdraw(context.Context, *MsgWithdraw) (*MsgWithdrawResponse, error)
	// InstantSpotMarketLaunch defines method for creating a spot market by paying
	// listing fee without governance
	InstantSpotMarketLaunch(context.Context, *MsgInstantSpotMarketLaunch) (*MsgInstantSpotMarketLaunchResponse, error)
	// CreateSpotLimitOrder defines a method for creating a new spot limit order.
	CreateSpotLimitOrder(context.Context, *MsgCreateSpotLimitOrder) (*MsgCreateSpotLimitOrderResponse, error)
	// BatchCreateSpotLimitOrder defines a method for creating a new batch of spot
	// limit orders.
	BatchCreateSpotLimitOrders(context.Context, *MsgBatchCreateSpotLimitOrders) (*MsgBatchCreateSpotLimitOrdersResponse, error)
	// CreateSpotMarketOrder defines a method for creating a new spot market
	// order.
	CreateSpotMarketOrder(context.Context, *MsgCreateSpotMarketOrder) (*MsgCreateSpotMarketOrderResponse, error)
	// MsgCancelSpotOrder defines a method for cancelling a spot order.
	CancelSpotOrder(context.Context, *MsgCancelSpotOrder) (*MsgCancelSpotOrderResponse, error)
	// BatchCancelSpotOrders defines a method for cancelling a batch of spot
	// orders in a given market.
	BatchCancelSpotOrders(context.Context, *MsgBatchCancelSpotOrders) (*MsgBatchCancelSpotOrdersResponse, error)
	// BatchUpdateOrders defines a method for updating a batch of orders.
	BatchUpdateOrders(context.Context, *MsgBatchUpdateOrders) (*MsgBatchUpdateOrdersResponse, error)
	// PrivilegedExecuteContract defines a method for executing a Cosmwasm
	// contract from the exchange module with privileged capabilities.
	PrivilegedExecuteContract(context.Context, *MsgPrivilegedExecuteContract) (*MsgPrivilegedExecuteContractResponse, error)
	// CreateDerivativeLimitOrder defines a method for creating a new derivative
	// limit order.
	CreateDerivativeLimitOrder(context.Context, *MsgCreateDerivativeLimitOrder) (*MsgCreateDerivativeLimitOrderResponse, error)
	// BatchCreateDerivativeLimitOrders defines a method for creating a new batch
	// of derivative limit orders.
	BatchCreateDerivativeLimitOrders(context.Context, *MsgBatchCreateDerivativeLimitOrders) (*MsgBatchCreateDerivativeLimitOrdersResponse, error)
	// MsgCreateDerivativeLimitOrder defines a method for creating a new
	// derivative market order.
	CreateDerivativeMarketOrder(context.Context, *MsgCreateDerivativeMarketOrder) (*MsgCreateDerivativeMarketOrderResponse, error)
	// MsgCancelDerivativeOrder defines a method for cancelling a derivative
	// order.
	CancelDerivativeOrder(context.Context, *MsgCancelDerivativeOrder) (*MsgCancelDerivativeOrderResponse, error)
	// MsgBatchCancelDerivativeOrders defines a method for cancelling a batch of
	// derivative limit orders.
	BatchCancelDerivativeOrders(context.Context, *MsgBatchCancelDerivativeOrders) (*MsgBatchCancelDerivativeOrdersResponse, error)
	// InstantBinaryOptionsMarketLaunch defines method for creating a binary
	// options market by paying listing fee without governance
	InstantBinaryOptionsMarketLaunch(context.Context, *MsgInstantBinaryOptionsMarketLaunch) (*MsgInstantBinaryOptionsMarketLaunchResponse, error)
	// CreateBinaryOptionsLimitOrder defines a method for creating a new binary
	// options limit order.
	CreateBinaryOptionsLimitOrder(context.Context, *MsgCreateBinaryOptionsLimitOrder) (*MsgCreateBinaryOptionsLimitOrderResponse, error)
	// CreateBinaryOptionsMarketOrder defines a method for creating a new binary
	// options market order.
	CreateBinaryOptionsMarketOrder(context.Context, *MsgCreateBinaryOptionsMarketOrder) (*MsgCreateBinaryOptionsMarketOrderResponse, error)
	// MsgCancelBinaryOptionsOrder defines a method for cancelling a binary
	// options order.
	CancelBinaryOptionsOrder(context.Context, *MsgCancelBinaryOptionsOrder) (*MsgCancelBinaryOptionsOrderResponse, error)
	// BatchCancelBinaryOptionsOrders defines a method for cancelling a batch of
	// binary options limit orders.
	BatchCancelBinaryOptionsOrders(context.Context, *MsgBatchCancelBinaryOptionsOrders) (*MsgBatchCancelBinaryOptionsOrdersResponse, error)
	// SubaccountTransfer defines a method for transfer between subaccounts
	SubaccountTransfer(context.Context, *MsgSubaccountTransfer) (*MsgSubaccountTransferResponse, error)
	// ExternalTransfer defines a method for transfer between external accounts
	ExternalTransfer(context.Context, *MsgExternalTransfer) (*MsgExternalTransferResponse, error)
	// LiquidatePosition defines a method for liquidating a position
	LiquidatePosition(context.Context, *MsgLiquidatePosition) (*MsgLiquidatePositionResponse, error)
	// EmergencySettleMarket defines a method for emergency settling a market
	EmergencySettleMarket(context.Context, *MsgEmergencySettleMarket) (*MsgEmergencySettleMarketResponse, error)
	// IncreasePositionMargin defines a method for increasing margin of a position
	IncreasePositionMargin(context.Context, *MsgIncreasePositionMargin) (*MsgIncreasePositionMarginResponse, error)
	// DecreasePositionMargin defines a method for decreasing margin of a position
	DecreasePositionMargin(context.Context, *MsgDecreasePositionMargin) (*MsgDecreasePositionMarginResponse, error)
	// RewardsOptOut defines a method for opting out of rewards
	RewardsOptOut(context.Context, *MsgRewardsOptOut) (*MsgRewardsOptOutResponse, error)
	// AdminUpdateBinaryOptionsMarket defines method for updating a binary options
	// market by admin
	AdminUpdateBinaryOptionsMarket(context.Context, *MsgAdminUpdateBinaryOptionsMarket) (*MsgAdminUpdateBinaryOptionsMarketResponse, error)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// UpdateSpotMarket modifies certain spot market fields (admin only)
	UpdateSpotMarket(context.Context, *MsgUpdateSpotMarket) (*MsgUpdateSpotMarketResponse, error)
	// UpdateDerivativeMarket modifies certain derivative market fields (admin
	// only)
	UpdateDerivativeMarket(context.Context, *MsgUpdateDerivativeMarket) (*MsgUpdateDerivativeMarketResponse, error)
	AuthorizeStakeGrants(context.Context, *MsgAuthorizeStakeGrants) (*MsgAuthorizeStakeGrantsResponse, error)
	ActivateStakeGrant(context.Context, *MsgActivateStakeGrant) (*MsgActivateStakeGrantResponse, error)
	BatchExchangeModification(context.Context, *MsgBatchExchangeModification) (*MsgBatchExchangeModificationResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMsgServer struct{}

func (UnimplementedMsgServer) Deposit(context.Context, *MsgDeposit) (*MsgDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deposit not implemented")
}
func (UnimplementedMsgServer) Withdraw(context.Context, *MsgWithdraw) (*MsgWithdrawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}
func (UnimplementedMsgServer) InstantSpotMarketLaunch(context.Context, *MsgInstantSpotMarketLaunch) (*MsgInstantSpotMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantSpotMarketLaunch not implemented")
}
func (UnimplementedMsgServer) CreateSpotLimitOrder(context.Context, *MsgCreateSpotLimitOrder) (*MsgCreateSpotLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSpotLimitOrder not implemented")
}
func (UnimplementedMsgServer) BatchCreateSpotLimitOrders(context.Context, *MsgBatchCreateSpotLimitOrders) (*MsgBatchCreateSpotLimitOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateSpotLimitOrders not implemented")
}
func (UnimplementedMsgServer) CreateSpotMarketOrder(context.Context, *MsgCreateSpotMarketOrder) (*MsgCreateSpotMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSpotMarketOrder not implemented")
}
func (UnimplementedMsgServer) CancelSpotOrder(context.Context, *MsgCancelSpotOrder) (*MsgCancelSpotOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelSpotOrder not implemented")
}
func (UnimplementedMsgServer) BatchCancelSpotOrders(context.Context, *MsgBatchCancelSpotOrders) (*MsgBatchCancelSpotOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelSpotOrders not implemented")
}
func (UnimplementedMsgServer) BatchUpdateOrders(context.Context, *MsgBatchUpdateOrders) (*MsgBatchUpdateOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateOrders not implemented")
}
func (UnimplementedMsgServer) PrivilegedExecuteContract(context.Context, *MsgPrivilegedExecuteContract) (*MsgPrivilegedExecuteContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivilegedExecuteContract not implemented")
}
func (UnimplementedMsgServer) CreateDerivativeLimitOrder(context.Context, *MsgCreateDerivativeLimitOrder) (*MsgCreateDerivativeLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDerivativeLimitOrder not implemented")
}
func (UnimplementedMsgServer) BatchCreateDerivativeLimitOrders(context.Context, *MsgBatchCreateDerivativeLimitOrders) (*MsgBatchCreateDerivativeLimitOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateDerivativeLimitOrders not implemented")
}
func (UnimplementedMsgServer) CreateDerivativeMarketOrder(context.Context, *MsgCreateDerivativeMarketOrder) (*MsgCreateDerivativeMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDerivativeMarketOrder not implemented")
}
func (UnimplementedMsgServer) CancelDerivativeOrder(context.Context, *MsgCancelDerivativeOrder) (*MsgCancelDerivativeOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelDerivativeOrder not implemented")
}
func (UnimplementedMsgServer) BatchCancelDerivativeOrders(context.Context, *MsgBatchCancelDerivativeOrders) (*MsgBatchCancelDerivativeOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelDerivativeOrders not implemented")
}
func (UnimplementedMsgServer) InstantBinaryOptionsMarketLaunch(context.Context, *MsgInstantBinaryOptionsMarketLaunch) (*MsgInstantBinaryOptionsMarketLaunchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstantBinaryOptionsMarketLaunch not implemented")
}
func (UnimplementedMsgServer) CreateBinaryOptionsLimitOrder(context.Context, *MsgCreateBinaryOptionsLimitOrder) (*MsgCreateBinaryOptionsLimitOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBinaryOptionsLimitOrder not implemented")
}
func (UnimplementedMsgServer) CreateBinaryOptionsMarketOrder(context.Context, *MsgCreateBinaryOptionsMarketOrder) (*MsgCreateBinaryOptionsMarketOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBinaryOptionsMarketOrder not implemented")
}
func (UnimplementedMsgServer) CancelBinaryOptionsOrder(context.Context, *MsgCancelBinaryOptionsOrder) (*MsgCancelBinaryOptionsOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBinaryOptionsOrder not implemented")
}
func (UnimplementedMsgServer) BatchCancelBinaryOptionsOrders(context.Context, *MsgBatchCancelBinaryOptionsOrders) (*MsgBatchCancelBinaryOptionsOrdersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCancelBinaryOptionsOrders not implemented")
}
func (UnimplementedMsgServer) SubaccountTransfer(context.Context, *MsgSubaccountTransfer) (*MsgSubaccountTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubaccountTransfer not implemented")
}
func (UnimplementedMsgServer) ExternalTransfer(context.Context, *MsgExternalTransfer) (*MsgExternalTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExternalTransfer not implemented")
}
func (UnimplementedMsgServer) LiquidatePosition(context.Context, *MsgLiquidatePosition) (*MsgLiquidatePositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LiquidatePosition not implemented")
}
func (UnimplementedMsgServer) EmergencySettleMarket(context.Context, *MsgEmergencySettleMarket) (*MsgEmergencySettleMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmergencySettleMarket not implemented")
}
func (UnimplementedMsgServer) IncreasePositionMargin(context.Context, *MsgIncreasePositionMargin) (*MsgIncreasePositionMarginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncreasePositionMargin not implemented")
}
func (UnimplementedMsgServer) DecreasePositionMargin(context.Context, *MsgDecreasePositionMargin) (*MsgDecreasePositionMarginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecreasePositionMargin not implemented")
}
func (UnimplementedMsgServer) RewardsOptOut(context.Context, *MsgRewardsOptOut) (*MsgRewardsOptOutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardsOptOut not implemented")
}
func (UnimplementedMsgServer) AdminUpdateBinaryOptionsMarket(context.Context, *MsgAdminUpdateBinaryOptionsMarket) (*MsgAdminUpdateBinaryOptionsMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminUpdateBinaryOptionsMarket not implemented")
}
func (UnimplementedMsgServer) UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (UnimplementedMsgServer) UpdateSpotMarket(context.Context, *MsgUpdateSpotMarket) (*MsgUpdateSpotMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSpotMarket not implemented")
}
func (UnimplementedMsgServer) UpdateDerivativeMarket(context.Context, *MsgUpdateDerivativeMarket) (*MsgUpdateDerivativeMarketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDerivativeMarket not implemented")
}
func (UnimplementedMsgServer) AuthorizeStakeGrants(context.Context, *MsgAuthorizeStakeGrants) (*MsgAuthorizeStakeGrantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthorizeStakeGrants not implemented")
}
func (UnimplementedMsgServer) ActivateStakeGrant(context.Context, *MsgActivateStakeGrant) (*MsgActivateStakeGrantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateStakeGrant not implemented")
}
func (UnimplementedMsgServer) BatchExchangeModification(context.Context, *MsgBatchExchangeModification) (*MsgBatchExchangeModificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchExchangeModification not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}
func (UnimplementedMsgServer) testEmbeddedByValue()             {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	// If the following call pancis, it indicates UnimplementedMsgServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_Deposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Deposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Deposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Deposit(ctx, req.(*MsgDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWithdraw)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Withdraw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Withdraw(ctx, req.(*MsgWithdraw))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantSpotMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantSpotMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantSpotMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_InstantSpotMarketLaunch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantSpotMarketLaunch(ctx, req.(*MsgInstantSpotMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSpotLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSpotLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSpotLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateSpotLimitOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSpotLimitOrder(ctx, req.(*MsgCreateSpotLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCreateSpotLimitOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCreateSpotLimitOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCreateSpotLimitOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BatchCreateSpotLimitOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCreateSpotLimitOrders(ctx, req.(*MsgBatchCreateSpotLimitOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateSpotMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateSpotMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateSpotMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateSpotMarketOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateSpotMarketOrder(ctx, req.(*MsgCreateSpotMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelSpotOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelSpotOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelSpotOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CancelSpotOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelSpotOrder(ctx, req.(*MsgCancelSpotOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelSpotOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelSpotOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelSpotOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BatchCancelSpotOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelSpotOrders(ctx, req.(*MsgBatchCancelSpotOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchUpdateOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchUpdateOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchUpdateOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BatchUpdateOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchUpdateOrders(ctx, req.(*MsgBatchUpdateOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PrivilegedExecuteContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPrivilegedExecuteContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PrivilegedExecuteContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_PrivilegedExecuteContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PrivilegedExecuteContract(ctx, req.(*MsgPrivilegedExecuteContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDerivativeLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDerivativeLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDerivativeLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateDerivativeLimitOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDerivativeLimitOrder(ctx, req.(*MsgCreateDerivativeLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCreateDerivativeLimitOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCreateDerivativeLimitOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCreateDerivativeLimitOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BatchCreateDerivativeLimitOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCreateDerivativeLimitOrders(ctx, req.(*MsgBatchCreateDerivativeLimitOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateDerivativeMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateDerivativeMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateDerivativeMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateDerivativeMarketOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateDerivativeMarketOrder(ctx, req.(*MsgCreateDerivativeMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelDerivativeOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelDerivativeOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelDerivativeOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CancelDerivativeOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelDerivativeOrder(ctx, req.(*MsgCancelDerivativeOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelDerivativeOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelDerivativeOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelDerivativeOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BatchCancelDerivativeOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelDerivativeOrders(ctx, req.(*MsgBatchCancelDerivativeOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InstantBinaryOptionsMarketLaunch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInstantBinaryOptionsMarketLaunch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InstantBinaryOptionsMarketLaunch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_InstantBinaryOptionsMarketLaunch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InstantBinaryOptionsMarketLaunch(ctx, req.(*MsgInstantBinaryOptionsMarketLaunch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBinaryOptionsLimitOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBinaryOptionsLimitOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBinaryOptionsLimitOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateBinaryOptionsLimitOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBinaryOptionsLimitOrder(ctx, req.(*MsgCreateBinaryOptionsLimitOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateBinaryOptionsMarketOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateBinaryOptionsMarketOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateBinaryOptionsMarketOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateBinaryOptionsMarketOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateBinaryOptionsMarketOrder(ctx, req.(*MsgCreateBinaryOptionsMarketOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelBinaryOptionsOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelBinaryOptionsOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelBinaryOptionsOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CancelBinaryOptionsOrder_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelBinaryOptionsOrder(ctx, req.(*MsgCancelBinaryOptionsOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchCancelBinaryOptionsOrders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchCancelBinaryOptionsOrders)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchCancelBinaryOptionsOrders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BatchCancelBinaryOptionsOrders_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchCancelBinaryOptionsOrders(ctx, req.(*MsgBatchCancelBinaryOptionsOrders))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubaccountTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubaccountTransfer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubaccountTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SubaccountTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubaccountTransfer(ctx, req.(*MsgSubaccountTransfer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ExternalTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgExternalTransfer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ExternalTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ExternalTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ExternalTransfer(ctx, req.(*MsgExternalTransfer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_LiquidatePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgLiquidatePosition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).LiquidatePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_LiquidatePosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).LiquidatePosition(ctx, req.(*MsgLiquidatePosition))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_EmergencySettleMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEmergencySettleMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).EmergencySettleMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_EmergencySettleMarket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).EmergencySettleMarket(ctx, req.(*MsgEmergencySettleMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IncreasePositionMargin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIncreasePositionMargin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IncreasePositionMargin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_IncreasePositionMargin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IncreasePositionMargin(ctx, req.(*MsgIncreasePositionMargin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DecreasePositionMargin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDecreasePositionMargin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DecreasePositionMargin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_DecreasePositionMargin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DecreasePositionMargin(ctx, req.(*MsgDecreasePositionMargin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RewardsOptOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRewardsOptOut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RewardsOptOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RewardsOptOut_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RewardsOptOut(ctx, req.(*MsgRewardsOptOut))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AdminUpdateBinaryOptionsMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAdminUpdateBinaryOptionsMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AdminUpdateBinaryOptionsMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AdminUpdateBinaryOptionsMarket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AdminUpdateBinaryOptionsMarket(ctx, req.(*MsgAdminUpdateBinaryOptionsMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateSpotMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateSpotMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateSpotMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateSpotMarket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateSpotMarket(ctx, req.(*MsgUpdateSpotMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDerivativeMarket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDerivativeMarket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDerivativeMarket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateDerivativeMarket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDerivativeMarket(ctx, req.(*MsgUpdateDerivativeMarket))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AuthorizeStakeGrants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAuthorizeStakeGrants)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AuthorizeStakeGrants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AuthorizeStakeGrants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AuthorizeStakeGrants(ctx, req.(*MsgAuthorizeStakeGrants))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ActivateStakeGrant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActivateStakeGrant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ActivateStakeGrant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_ActivateStakeGrant_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ActivateStakeGrant(ctx, req.(*MsgActivateStakeGrant))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BatchExchangeModification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBatchExchangeModification)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BatchExchangeModification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BatchExchangeModification_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BatchExchangeModification(ctx, req.(*MsgBatchExchangeModification))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "injective.exchange.v1beta1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deposit",
			Handler:    _Msg_Deposit_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _Msg_Withdraw_Handler,
		},
		{
			MethodName: "InstantSpotMarketLaunch",
			Handler:    _Msg_InstantSpotMarketLaunch_Handler,
		},
		{
			MethodName: "CreateSpotLimitOrder",
			Handler:    _Msg_CreateSpotLimitOrder_Handler,
		},
		{
			MethodName: "BatchCreateSpotLimitOrders",
			Handler:    _Msg_BatchCreateSpotLimitOrders_Handler,
		},
		{
			MethodName: "CreateSpotMarketOrder",
			Handler:    _Msg_CreateSpotMarketOrder_Handler,
		},
		{
			MethodName: "CancelSpotOrder",
			Handler:    _Msg_CancelSpotOrder_Handler,
		},
		{
			MethodName: "BatchCancelSpotOrders",
			Handler:    _Msg_BatchCancelSpotOrders_Handler,
		},
		{
			MethodName: "BatchUpdateOrders",
			Handler:    _Msg_BatchUpdateOrders_Handler,
		},
		{
			MethodName: "PrivilegedExecuteContract",
			Handler:    _Msg_PrivilegedExecuteContract_Handler,
		},
		{
			MethodName: "CreateDerivativeLimitOrder",
			Handler:    _Msg_CreateDerivativeLimitOrder_Handler,
		},
		{
			MethodName: "BatchCreateDerivativeLimitOrders",
			Handler:    _Msg_BatchCreateDerivativeLimitOrders_Handler,
		},
		{
			MethodName: "CreateDerivativeMarketOrder",
			Handler:    _Msg_CreateDerivativeMarketOrder_Handler,
		},
		{
			MethodName: "CancelDerivativeOrder",
			Handler:    _Msg_CancelDerivativeOrder_Handler,
		},
		{
			MethodName: "BatchCancelDerivativeOrders",
			Handler:    _Msg_BatchCancelDerivativeOrders_Handler,
		},
		{
			MethodName: "InstantBinaryOptionsMarketLaunch",
			Handler:    _Msg_InstantBinaryOptionsMarketLaunch_Handler,
		},
		{
			MethodName: "CreateBinaryOptionsLimitOrder",
			Handler:    _Msg_CreateBinaryOptionsLimitOrder_Handler,
		},
		{
			MethodName: "CreateBinaryOptionsMarketOrder",
			Handler:    _Msg_CreateBinaryOptionsMarketOrder_Handler,
		},
		{
			MethodName: "CancelBinaryOptionsOrder",
			Handler:    _Msg_CancelBinaryOptionsOrder_Handler,
		},
		{
			MethodName: "BatchCancelBinaryOptionsOrders",
			Handler:    _Msg_BatchCancelBinaryOptionsOrders_Handler,
		},
		{
			MethodName: "SubaccountTransfer",
			Handler:    _Msg_SubaccountTransfer_Handler,
		},
		{
			MethodName: "ExternalTransfer",
			Handler:    _Msg_ExternalTransfer_Handler,
		},
		{
			MethodName: "LiquidatePosition",
			Handler:    _Msg_LiquidatePosition_Handler,
		},
		{
			MethodName: "EmergencySettleMarket",
			Handler:    _Msg_EmergencySettleMarket_Handler,
		},
		{
			MethodName: "IncreasePositionMargin",
			Handler:    _Msg_IncreasePositionMargin_Handler,
		},
		{
			MethodName: "DecreasePositionMargin",
			Handler:    _Msg_DecreasePositionMargin_Handler,
		},
		{
			MethodName: "RewardsOptOut",
			Handler:    _Msg_RewardsOptOut_Handler,
		},
		{
			MethodName: "AdminUpdateBinaryOptionsMarket",
			Handler:    _Msg_AdminUpdateBinaryOptionsMarket_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "UpdateSpotMarket",
			Handler:    _Msg_UpdateSpotMarket_Handler,
		},
		{
			MethodName: "UpdateDerivativeMarket",
			Handler:    _Msg_UpdateDerivativeMarket_Handler,
		},
		{
			MethodName: "AuthorizeStakeGrants",
			Handler:    _Msg_AuthorizeStakeGrants_Handler,
		},
		{
			MethodName: "ActivateStakeGrant",
			Handler:    _Msg_ActivateStakeGrant_Handler,
		},
		{
			MethodName: "BatchExchangeModification",
			Handler:    _Msg_BatchExchangeModification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "injective/exchange/v1beta1/tx.proto",
}
