// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        (unknown)
// source: injective/exchange/v2/order.proto

package v2

import (
	_ "github.com/cosmos/gogoproto/gogoproto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type OrderType int32

const (
	OrderType_UNSPECIFIED OrderType = 0
	OrderType_BUY         OrderType = 1
	OrderType_SELL        OrderType = 2
	OrderType_STOP_BUY    OrderType = 3
	OrderType_STOP_SELL   OrderType = 4
	OrderType_TAKE_BUY    OrderType = 5
	OrderType_TAKE_SELL   OrderType = 6
	OrderType_BUY_PO      OrderType = 7
	OrderType_SELL_PO     OrderType = 8
	OrderType_BUY_ATOMIC  OrderType = 9
	OrderType_SELL_ATOMIC OrderType = 10
)

// Enum value maps for OrderType.
var (
	OrderType_name = map[int32]string{
		0:  "UNSPECIFIED",
		1:  "BUY",
		2:  "SELL",
		3:  "STOP_BUY",
		4:  "STOP_SELL",
		5:  "TAKE_BUY",
		6:  "TAKE_SELL",
		7:  "BUY_PO",
		8:  "SELL_PO",
		9:  "BUY_ATOMIC",
		10: "SELL_ATOMIC",
	}
	OrderType_value = map[string]int32{
		"UNSPECIFIED": 0,
		"BUY":         1,
		"SELL":        2,
		"STOP_BUY":    3,
		"STOP_SELL":   4,
		"TAKE_BUY":    5,
		"TAKE_SELL":   6,
		"BUY_PO":      7,
		"SELL_PO":     8,
		"BUY_ATOMIC":  9,
		"SELL_ATOMIC": 10,
	}
)

func (x OrderType) Enum() *OrderType {
	p := new(OrderType)
	*p = x
	return p
}

func (x OrderType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderType) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v2_order_proto_enumTypes[0].Descriptor()
}

func (OrderType) Type() protoreflect.EnumType {
	return &file_injective_exchange_v2_order_proto_enumTypes[0]
}

func (x OrderType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderType.Descriptor instead.
func (OrderType) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{0}
}

type OrderMask int32

const (
	OrderMask_UNUSED                  OrderMask = 0
	OrderMask_ANY                     OrderMask = 1
	OrderMask_REGULAR                 OrderMask = 2
	OrderMask_CONDITIONAL             OrderMask = 4
	OrderMask_DIRECTION_BUY_OR_HIGHER OrderMask = 8  // for conditional orders means HIGHER
	OrderMask_DIRECTION_SELL_OR_LOWER OrderMask = 16 // for conditional orders means LOWER
	OrderMask_TYPE_MARKET             OrderMask = 32
	OrderMask_TYPE_LIMIT              OrderMask = 64
)

// Enum value maps for OrderMask.
var (
	OrderMask_name = map[int32]string{
		0:  "UNUSED",
		1:  "ANY",
		2:  "REGULAR",
		4:  "CONDITIONAL",
		8:  "DIRECTION_BUY_OR_HIGHER",
		16: "DIRECTION_SELL_OR_LOWER",
		32: "TYPE_MARKET",
		64: "TYPE_LIMIT",
	}
	OrderMask_value = map[string]int32{
		"UNUSED":                  0,
		"ANY":                     1,
		"REGULAR":                 2,
		"CONDITIONAL":             4,
		"DIRECTION_BUY_OR_HIGHER": 8,
		"DIRECTION_SELL_OR_LOWER": 16,
		"TYPE_MARKET":             32,
		"TYPE_LIMIT":              64,
	}
)

func (x OrderMask) Enum() *OrderMask {
	p := new(OrderMask)
	*p = x
	return p
}

func (x OrderMask) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderMask) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v2_order_proto_enumTypes[1].Descriptor()
}

func (OrderMask) Type() protoreflect.EnumType {
	return &file_injective_exchange_v2_order_proto_enumTypes[1]
}

func (x OrderMask) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderMask.Descriptor instead.
func (OrderMask) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{1}
}

type AtomicMarketOrderAccessLevel int32

const (
	AtomicMarketOrderAccessLevel_Nobody AtomicMarketOrderAccessLevel = 0
	// currently unsupported
	AtomicMarketOrderAccessLevel_BeginBlockerSmartContractsOnly AtomicMarketOrderAccessLevel = 1
	AtomicMarketOrderAccessLevel_SmartContractsOnly             AtomicMarketOrderAccessLevel = 2
	AtomicMarketOrderAccessLevel_Everyone                       AtomicMarketOrderAccessLevel = 3
)

// Enum value maps for AtomicMarketOrderAccessLevel.
var (
	AtomicMarketOrderAccessLevel_name = map[int32]string{
		0: "Nobody",
		1: "BeginBlockerSmartContractsOnly",
		2: "SmartContractsOnly",
		3: "Everyone",
	}
	AtomicMarketOrderAccessLevel_value = map[string]int32{
		"Nobody":                         0,
		"BeginBlockerSmartContractsOnly": 1,
		"SmartContractsOnly":             2,
		"Everyone":                       3,
	}
)

func (x AtomicMarketOrderAccessLevel) Enum() *AtomicMarketOrderAccessLevel {
	p := new(AtomicMarketOrderAccessLevel)
	*p = x
	return p
}

func (x AtomicMarketOrderAccessLevel) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AtomicMarketOrderAccessLevel) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v2_order_proto_enumTypes[2].Descriptor()
}

func (AtomicMarketOrderAccessLevel) Type() protoreflect.EnumType {
	return &file_injective_exchange_v2_order_proto_enumTypes[2]
}

func (x AtomicMarketOrderAccessLevel) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AtomicMarketOrderAccessLevel.Descriptor instead.
func (AtomicMarketOrderAccessLevel) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{2}
}

type OrderInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// bytes32 subaccount ID that created the order
	SubaccountId string `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// address fee_recipient address that will receive fees for the order
	FeeRecipient string `protobuf:"bytes,2,opt,name=fee_recipient,json=feeRecipient,proto3" json:"fee_recipient,omitempty"`
	// price of the order (in human readable format)
	Price string `protobuf:"bytes,3,opt,name=price,proto3" json:"price,omitempty"`
	// quantity of the order (in human readable format)
	Quantity string `protobuf:"bytes,4,opt,name=quantity,proto3" json:"quantity,omitempty"`
	// the client order ID (optional)
	Cid           string `protobuf:"bytes,5,opt,name=cid,proto3" json:"cid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderInfo) Reset() {
	*x = OrderInfo{}
	mi := &file_injective_exchange_v2_order_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderInfo) ProtoMessage() {}

func (x *OrderInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_order_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderInfo.ProtoReflect.Descriptor instead.
func (*OrderInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{0}
}

func (x *OrderInfo) GetSubaccountId() string {
	if x != nil {
		return x.SubaccountId
	}
	return ""
}

func (x *OrderInfo) GetFeeRecipient() string {
	if x != nil {
		return x.FeeRecipient
	}
	return ""
}

func (x *OrderInfo) GetPrice() string {
	if x != nil {
		return x.Price
	}
	return ""
}

func (x *OrderInfo) GetQuantity() string {
	if x != nil {
		return x.Quantity
	}
	return ""
}

func (x *OrderInfo) GetCid() string {
	if x != nil {
		return x.Cid
	}
	return ""
}

type SpotOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market_id represents the unique ID of the market
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,2,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,3,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v2.OrderType" json:"order_type,omitempty"`
	// trigger_price is the trigger price used by stop/take orders (in human
	// readable format) (optional)
	TriggerPrice string `protobuf:"bytes,4,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	// expiration block is the block number at which the order will expire
	ExpirationBlock int64 `protobuf:"varint,5,opt,name=expiration_block,json=expirationBlock,proto3" json:"expiration_block,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SpotOrder) Reset() {
	*x = SpotOrder{}
	mi := &file_injective_exchange_v2_order_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotOrder) ProtoMessage() {}

func (x *SpotOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_order_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotOrder.ProtoReflect.Descriptor instead.
func (*SpotOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{1}
}

func (x *SpotOrder) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *SpotOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *SpotOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *SpotOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *SpotOrder) GetExpirationBlock() int64 {
	if x != nil {
		return x.ExpirationBlock
	}
	return 0
}

// A valid Spot market order with Metadata.
type SpotMarketOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo   *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	BalanceHold string     `protobuf:"bytes,2,opt,name=balance_hold,json=balanceHold,proto3" json:"balance_hold,omitempty"`
	OrderHash   []byte     `protobuf:"bytes,3,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,4,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v2.OrderType" json:"order_type,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpotMarketOrder) Reset() {
	*x = SpotMarketOrder{}
	mi := &file_injective_exchange_v2_order_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotMarketOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotMarketOrder) ProtoMessage() {}

func (x *SpotMarketOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_order_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotMarketOrder.ProtoReflect.Descriptor instead.
func (*SpotMarketOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{2}
}

func (x *SpotMarketOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *SpotMarketOrder) GetBalanceHold() string {
	if x != nil {
		return x.BalanceHold
	}
	return ""
}

func (x *SpotMarketOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

func (x *SpotMarketOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *SpotMarketOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

// A valid Spot limit order with Metadata.
type SpotLimitOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,2,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v2.OrderType" json:"order_type,omitempty"`
	// the amount of the quantity remaining fillable
	Fillable string `protobuf:"bytes,3,opt,name=fillable,proto3" json:"fillable,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice string `protobuf:"bytes,4,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	// order hash
	OrderHash []byte `protobuf:"bytes,5,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// expiration block is the block number at which the order will expire
	ExpirationBlock int64 `protobuf:"varint,6,opt,name=expiration_block,json=expirationBlock,proto3" json:"expiration_block,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SpotLimitOrder) Reset() {
	*x = SpotLimitOrder{}
	mi := &file_injective_exchange_v2_order_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotLimitOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotLimitOrder) ProtoMessage() {}

func (x *SpotLimitOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_order_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotLimitOrder.ProtoReflect.Descriptor instead.
func (*SpotLimitOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{3}
}

func (x *SpotLimitOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *SpotLimitOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *SpotLimitOrder) GetFillable() string {
	if x != nil {
		return x.Fillable
	}
	return ""
}

func (x *SpotLimitOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *SpotLimitOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

func (x *SpotLimitOrder) GetExpirationBlock() int64 {
	if x != nil {
		return x.ExpirationBlock
	}
	return 0
}

type DerivativeOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market_id represents the unique ID of the market
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,2,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,3,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v2.OrderType" json:"order_type,omitempty"`
	// margin is the margin used by the limit order (in human readable format)
	Margin string `protobuf:"bytes,4,opt,name=margin,proto3" json:"margin,omitempty"`
	// trigger_price is the trigger price used by stop/take orders (in human
	// readable format) (optional)
	TriggerPrice string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	// expiration block is the block number at which the order will expire
	ExpirationBlock int64 `protobuf:"varint,6,opt,name=expiration_block,json=expirationBlock,proto3" json:"expiration_block,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DerivativeOrder) Reset() {
	*x = DerivativeOrder{}
	mi := &file_injective_exchange_v2_order_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeOrder) ProtoMessage() {}

func (x *DerivativeOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_order_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeOrder.ProtoReflect.Descriptor instead.
func (*DerivativeOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{4}
}

func (x *DerivativeOrder) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *DerivativeOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *DerivativeOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *DerivativeOrder) GetMargin() string {
	if x != nil {
		return x.Margin
	}
	return ""
}

func (x *DerivativeOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *DerivativeOrder) GetExpirationBlock() int64 {
	if x != nil {
		return x.ExpirationBlock
	}
	return 0
}

// A valid Derivative market order with Metadata.
type DerivativeMarketOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType  OrderType `protobuf:"varint,2,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v2.OrderType" json:"order_type,omitempty"`
	Margin     string    `protobuf:"bytes,3,opt,name=margin,proto3" json:"margin,omitempty"`
	MarginHold string    `protobuf:"bytes,4,opt,name=margin_hold,json=marginHold,proto3" json:"margin_hold,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice  string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	OrderHash     []byte `protobuf:"bytes,6,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DerivativeMarketOrder) Reset() {
	*x = DerivativeMarketOrder{}
	mi := &file_injective_exchange_v2_order_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeMarketOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeMarketOrder) ProtoMessage() {}

func (x *DerivativeMarketOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_order_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeMarketOrder.ProtoReflect.Descriptor instead.
func (*DerivativeMarketOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{5}
}

func (x *DerivativeMarketOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *DerivativeMarketOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *DerivativeMarketOrder) GetMargin() string {
	if x != nil {
		return x.Margin
	}
	return ""
}

func (x *DerivativeMarketOrder) GetMarginHold() string {
	if x != nil {
		return x.MarginHold
	}
	return ""
}

func (x *DerivativeMarketOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *DerivativeMarketOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

// A valid Derivative limit order with Metadata.
type DerivativeLimitOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_info contains the information of the order
	OrderInfo *OrderInfo `protobuf:"bytes,1,opt,name=order_info,json=orderInfo,proto3" json:"order_info,omitempty"`
	// order types
	OrderType OrderType `protobuf:"varint,2,opt,name=order_type,json=orderType,proto3,enum=injective.exchange.v2.OrderType" json:"order_type,omitempty"`
	// margin is the margin used by the limit order
	Margin string `protobuf:"bytes,3,opt,name=margin,proto3" json:"margin,omitempty"`
	// the amount of the quantity remaining fillable
	Fillable string `protobuf:"bytes,4,opt,name=fillable,proto3" json:"fillable,omitempty"`
	// trigger_price is the trigger price used by stop/take orders
	TriggerPrice string `protobuf:"bytes,5,opt,name=trigger_price,json=triggerPrice,proto3" json:"trigger_price,omitempty"`
	OrderHash    []byte `protobuf:"bytes,6,opt,name=order_hash,json=orderHash,proto3" json:"order_hash,omitempty"`
	// expiration block is the block number at which the order will expire
	ExpirationBlock int64 `protobuf:"varint,7,opt,name=expiration_block,json=expirationBlock,proto3" json:"expiration_block,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DerivativeLimitOrder) Reset() {
	*x = DerivativeLimitOrder{}
	mi := &file_injective_exchange_v2_order_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeLimitOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeLimitOrder) ProtoMessage() {}

func (x *DerivativeLimitOrder) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_order_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeLimitOrder.ProtoReflect.Descriptor instead.
func (*DerivativeLimitOrder) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_order_proto_rawDescGZIP(), []int{6}
}

func (x *DerivativeLimitOrder) GetOrderInfo() *OrderInfo {
	if x != nil {
		return x.OrderInfo
	}
	return nil
}

func (x *DerivativeLimitOrder) GetOrderType() OrderType {
	if x != nil {
		return x.OrderType
	}
	return OrderType_UNSPECIFIED
}

func (x *DerivativeLimitOrder) GetMargin() string {
	if x != nil {
		return x.Margin
	}
	return ""
}

func (x *DerivativeLimitOrder) GetFillable() string {
	if x != nil {
		return x.Fillable
	}
	return ""
}

func (x *DerivativeLimitOrder) GetTriggerPrice() string {
	if x != nil {
		return x.TriggerPrice
	}
	return ""
}

func (x *DerivativeLimitOrder) GetOrderHash() []byte {
	if x != nil {
		return x.OrderHash
	}
	return nil
}

func (x *DerivativeLimitOrder) GetExpirationBlock() int64 {
	if x != nil {
		return x.ExpirationBlock
	}
	return 0
}

var File_injective_exchange_v2_order_proto protoreflect.FileDescriptor

const file_injective_exchange_v2_order_proto_rawDesc = "" +
	"\n" +
	"!injective/exchange/v2/order.proto\x12\x15injective.exchange.v2\x1a\x14gogoproto/gogo.proto\"\xe3\x01\n" +
	"\tOrderInfo\x12#\n" +
	"\rsubaccount_id\x18\x01 \x01(\tR\fsubaccountId\x12#\n" +
	"\rfee_recipient\x18\x02 \x01(\tR\ffeeRecipient\x129\n" +
	"\x05price\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x05price\x12?\n" +
	"\bquantity\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bquantity\x12\x10\n" +
	"\x03cid\x18\x05 \x01(\tR\x03cid\"\xab\x02\n" +
	"\tSpotOrder\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12E\n" +
	"\n" +
	"order_info\x18\x02 \x01(\v2 .injective.exchange.v2.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12?\n" +
	"\n" +
	"order_type\x18\x03 \x01(\x0e2 .injective.exchange.v2.OrderTypeR\torderType\x12H\n" +
	"\rtrigger_price\x18\x04 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12/\n" +
	"\x10expiration_block\x18\x05 \x01(\x03B\x04\xc8\xde\x1f\x01R\x0fexpirationBlock\"\xca\x02\n" +
	"\x0fSpotMarketOrder\x12E\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2 .injective.exchange.v2.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12F\n" +
	"\fbalance_hold\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vbalanceHold\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x03 \x01(\fR\torderHash\x12?\n" +
	"\n" +
	"order_type\x18\x04 \x01(\x0e2 .injective.exchange.v2.OrderTypeR\torderType\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\"\xf3\x02\n" +
	"\x0eSpotLimitOrder\x12E\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2 .injective.exchange.v2.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12?\n" +
	"\n" +
	"order_type\x18\x02 \x01(\x0e2 .injective.exchange.v2.OrderTypeR\torderType\x12?\n" +
	"\bfillable\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bfillable\x12H\n" +
	"\rtrigger_price\x18\x04 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x05 \x01(\fR\torderHash\x12/\n" +
	"\x10expiration_block\x18\x06 \x01(\x03B\x04\xc8\xde\x1f\x01R\x0fexpirationBlock\"\xee\x02\n" +
	"\x0fDerivativeOrder\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12E\n" +
	"\n" +
	"order_info\x18\x02 \x01(\v2 .injective.exchange.v2.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12?\n" +
	"\n" +
	"order_type\x18\x03 \x01(\x0e2 .injective.exchange.v2.OrderTypeR\torderType\x12;\n" +
	"\x06margin\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06margin\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12/\n" +
	"\x10expiration_block\x18\x06 \x01(\x03B\x04\xc8\xde\x1f\x01R\x0fexpirationBlock\"\x8b\x03\n" +
	"\x15DerivativeMarketOrder\x12E\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2 .injective.exchange.v2.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12?\n" +
	"\n" +
	"order_type\x18\x02 \x01(\x0e2 .injective.exchange.v2.OrderTypeR\torderType\x12;\n" +
	"\x06margin\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06margin\x12D\n" +
	"\vmargin_hold\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\n" +
	"marginHold\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x06 \x01(\fR\torderHash\"\xb6\x03\n" +
	"\x14DerivativeLimitOrder\x12E\n" +
	"\n" +
	"order_info\x18\x01 \x01(\v2 .injective.exchange.v2.OrderInfoB\x04\xc8\xde\x1f\x00R\torderInfo\x12?\n" +
	"\n" +
	"order_type\x18\x02 \x01(\x0e2 .injective.exchange.v2.OrderTypeR\torderType\x12;\n" +
	"\x06margin\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x06margin\x12?\n" +
	"\bfillable\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\bfillable\x12H\n" +
	"\rtrigger_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftriggerPrice\x12\x1d\n" +
	"\n" +
	"order_hash\x18\x06 \x01(\fR\torderHash\x12/\n" +
	"\x10expiration_block\x18\a \x01(\x03B\x04\xc8\xde\x1f\x01R\x0fexpirationBlock*\xbb\x02\n" +
	"\tOrderType\x12 \n" +
	"\vUNSPECIFIED\x10\x00\x1a\x0f\x8a\x9d \vUNSPECIFIED\x12\x10\n" +
	"\x03BUY\x10\x01\x1a\a\x8a\x9d \x03BUY\x12\x12\n" +
	"\x04SELL\x10\x02\x1a\b\x8a\x9d \x04SELL\x12\x1a\n" +
	"\bSTOP_BUY\x10\x03\x1a\f\x8a\x9d \bSTOP_BUY\x12\x1c\n" +
	"\tSTOP_SELL\x10\x04\x1a\r\x8a\x9d \tSTOP_SELL\x12\x1a\n" +
	"\bTAKE_BUY\x10\x05\x1a\f\x8a\x9d \bTAKE_BUY\x12\x1c\n" +
	"\tTAKE_SELL\x10\x06\x1a\r\x8a\x9d \tTAKE_SELL\x12\x16\n" +
	"\x06BUY_PO\x10\a\x1a\n" +
	"\x8a\x9d \x06BUY_PO\x12\x18\n" +
	"\aSELL_PO\x10\b\x1a\v\x8a\x9d \aSELL_PO\x12\x1e\n" +
	"\n" +
	"BUY_ATOMIC\x10\t\x1a\x0e\x8a\x9d \n" +
	"BUY_ATOMIC\x12 \n" +
	"\vSELL_ATOMIC\x10\n" +
	"\x1a\x0f\x8a\x9d \vSELL_ATOMIC*\x89\x02\n" +
	"\tOrderMask\x12\x16\n" +
	"\x06UNUSED\x10\x00\x1a\n" +
	"\x8a\x9d \x06UNUSED\x12\x10\n" +
	"\x03ANY\x10\x01\x1a\a\x8a\x9d \x03ANY\x12\x18\n" +
	"\aREGULAR\x10\x02\x1a\v\x8a\x9d \aREGULAR\x12 \n" +
	"\vCONDITIONAL\x10\x04\x1a\x0f\x8a\x9d \vCONDITIONAL\x12.\n" +
	"\x17DIRECTION_BUY_OR_HIGHER\x10\b\x1a\x11\x8a\x9d \rBUY_OR_HIGHER\x12.\n" +
	"\x17DIRECTION_SELL_OR_LOWER\x10\x10\x1a\x11\x8a\x9d \rSELL_OR_LOWER\x12\x1b\n" +
	"\vTYPE_MARKET\x10 \x1a\n" +
	"\x8a\x9d \x06MARKET\x12\x19\n" +
	"\n" +
	"TYPE_LIMIT\x10@\x1a\t\x8a\x9d \x05LIMIT*t\n" +
	"\x1cAtomicMarketOrderAccessLevel\x12\n" +
	"\n" +
	"\x06Nobody\x10\x00\x12\"\n" +
	"\x1eBeginBlockerSmartContractsOnly\x10\x01\x12\x16\n" +
	"\x12SmartContractsOnly\x10\x02\x12\f\n" +
	"\bEveryone\x10\x03BSZQgithub.com/InjectiveLabs/injective-core/injective-chain/modules/exchange/types/v2b\x06proto3"

var (
	file_injective_exchange_v2_order_proto_rawDescOnce sync.Once
	file_injective_exchange_v2_order_proto_rawDescData []byte
)

func file_injective_exchange_v2_order_proto_rawDescGZIP() []byte {
	file_injective_exchange_v2_order_proto_rawDescOnce.Do(func() {
		file_injective_exchange_v2_order_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_injective_exchange_v2_order_proto_rawDesc), len(file_injective_exchange_v2_order_proto_rawDesc)))
	})
	return file_injective_exchange_v2_order_proto_rawDescData
}

var file_injective_exchange_v2_order_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_injective_exchange_v2_order_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_injective_exchange_v2_order_proto_goTypes = []any{
	(OrderType)(0),                    // 0: injective.exchange.v2.OrderType
	(OrderMask)(0),                    // 1: injective.exchange.v2.OrderMask
	(AtomicMarketOrderAccessLevel)(0), // 2: injective.exchange.v2.AtomicMarketOrderAccessLevel
	(*OrderInfo)(nil),                 // 3: injective.exchange.v2.OrderInfo
	(*SpotOrder)(nil),                 // 4: injective.exchange.v2.SpotOrder
	(*SpotMarketOrder)(nil),           // 5: injective.exchange.v2.SpotMarketOrder
	(*SpotLimitOrder)(nil),            // 6: injective.exchange.v2.SpotLimitOrder
	(*DerivativeOrder)(nil),           // 7: injective.exchange.v2.DerivativeOrder
	(*DerivativeMarketOrder)(nil),     // 8: injective.exchange.v2.DerivativeMarketOrder
	(*DerivativeLimitOrder)(nil),      // 9: injective.exchange.v2.DerivativeLimitOrder
}
var file_injective_exchange_v2_order_proto_depIdxs = []int32{
	3,  // 0: injective.exchange.v2.SpotOrder.order_info:type_name -> injective.exchange.v2.OrderInfo
	0,  // 1: injective.exchange.v2.SpotOrder.order_type:type_name -> injective.exchange.v2.OrderType
	3,  // 2: injective.exchange.v2.SpotMarketOrder.order_info:type_name -> injective.exchange.v2.OrderInfo
	0,  // 3: injective.exchange.v2.SpotMarketOrder.order_type:type_name -> injective.exchange.v2.OrderType
	3,  // 4: injective.exchange.v2.SpotLimitOrder.order_info:type_name -> injective.exchange.v2.OrderInfo
	0,  // 5: injective.exchange.v2.SpotLimitOrder.order_type:type_name -> injective.exchange.v2.OrderType
	3,  // 6: injective.exchange.v2.DerivativeOrder.order_info:type_name -> injective.exchange.v2.OrderInfo
	0,  // 7: injective.exchange.v2.DerivativeOrder.order_type:type_name -> injective.exchange.v2.OrderType
	3,  // 8: injective.exchange.v2.DerivativeMarketOrder.order_info:type_name -> injective.exchange.v2.OrderInfo
	0,  // 9: injective.exchange.v2.DerivativeMarketOrder.order_type:type_name -> injective.exchange.v2.OrderType
	3,  // 10: injective.exchange.v2.DerivativeLimitOrder.order_info:type_name -> injective.exchange.v2.OrderInfo
	0,  // 11: injective.exchange.v2.DerivativeLimitOrder.order_type:type_name -> injective.exchange.v2.OrderType
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_injective_exchange_v2_order_proto_init() }
func file_injective_exchange_v2_order_proto_init() {
	if File_injective_exchange_v2_order_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_injective_exchange_v2_order_proto_rawDesc), len(file_injective_exchange_v2_order_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_injective_exchange_v2_order_proto_goTypes,
		DependencyIndexes: file_injective_exchange_v2_order_proto_depIdxs,
		EnumInfos:         file_injective_exchange_v2_order_proto_enumTypes,
		MessageInfos:      file_injective_exchange_v2_order_proto_msgTypes,
	}.Build()
	File_injective_exchange_v2_order_proto = out.File
	file_injective_exchange_v2_order_proto_goTypes = nil
	file_injective_exchange_v2_order_proto_depIdxs = nil
}
