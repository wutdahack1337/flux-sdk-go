// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        (unknown)
// source: injective/exchange/v2/market.proto

package v2

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "github.com/cosmos/gogoproto/gogoproto"
	types "github.com/wutdahack1337/flux-sdk-go/chain/modules/injective/chain/oracle/types"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type MarketStatus int32

const (
	MarketStatus_Unspecified MarketStatus = 0
	MarketStatus_Active      MarketStatus = 1
	MarketStatus_Paused      MarketStatus = 2
	MarketStatus_Demolished  MarketStatus = 3
	MarketStatus_Expired     MarketStatus = 4
)

// Enum value maps for MarketStatus.
var (
	MarketStatus_name = map[int32]string{
		0: "Unspecified",
		1: "Active",
		2: "Paused",
		3: "Demolished",
		4: "Expired",
	}
	MarketStatus_value = map[string]int32{
		"Unspecified": 0,
		"Active":      1,
		"Paused":      2,
		"Demolished":  3,
		"Expired":     4,
	}
)

func (x MarketStatus) Enum() *MarketStatus {
	p := new(MarketStatus)
	*p = x
	return p
}

func (x MarketStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MarketStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_injective_exchange_v2_market_proto_enumTypes[0].Descriptor()
}

func (MarketStatus) Type() protoreflect.EnumType {
	return &file_injective_exchange_v2_market_proto_enumTypes[0]
}

func (x MarketStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MarketStatus.Descriptor instead.
func (MarketStatus) EnumDescriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{0}
}

type MarketFeeMultiplier struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MarketId      string                 `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	FeeMultiplier string                 `protobuf:"bytes,2,opt,name=fee_multiplier,json=feeMultiplier,proto3" json:"fee_multiplier,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketFeeMultiplier) Reset() {
	*x = MarketFeeMultiplier{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketFeeMultiplier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketFeeMultiplier) ProtoMessage() {}

func (x *MarketFeeMultiplier) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketFeeMultiplier.ProtoReflect.Descriptor instead.
func (*MarketFeeMultiplier) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{0}
}

func (x *MarketFeeMultiplier) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *MarketFeeMultiplier) GetFeeMultiplier() string {
	if x != nil {
		return x.FeeMultiplier
	}
	return ""
}

// An object describing trade pair of two assets.
type SpotMarket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A name of the pair in format AAA/BBB, where AAA is base asset, BBB is quote
	// asset.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Coin denom used for the base asset
	BaseDenom string `protobuf:"bytes,2,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	// Coin used for the quote asset
	QuoteDenom string `protobuf:"bytes,3,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// maker_fee_rate defines the fee percentage makers pay when trading
	MakerFeeRate string `protobuf:"bytes,4,opt,name=maker_fee_rate,json=makerFeeRate,proto3" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the fee percentage takers pay when trading
	TakerFeeRate string `protobuf:"bytes,5,opt,name=taker_fee_rate,json=takerFeeRate,proto3" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the percentage of the transaction fee shared
	// with the relayer in a derivative market
	RelayerFeeShareRate string `protobuf:"bytes,6,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3" json:"relayer_fee_share_rate,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,7,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,8,opt,name=status,proto3,enum=injective.exchange.v2.MarketStatus" json:"status,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price required
	// for orders in the market (in human readable format)
	MinPriceTickSize string `protobuf:"bytes,9,opt,name=min_price_tick_size,json=minPriceTickSize,proto3" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market (in human readable format)
	MinQuantityTickSize string `protobuf:"bytes,10,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3" json:"min_quantity_tick_size,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market (in human readable format)
	MinNotional string `protobuf:"bytes,11,opt,name=min_notional,json=minNotional,proto3" json:"min_notional,omitempty"`
	// current market admin
	Admin string `protobuf:"bytes,12,opt,name=admin,proto3" json:"admin,omitempty"`
	// level of admin permissions
	AdminPermissions uint32 `protobuf:"varint,13,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
	// base token decimals
	BaseDecimals uint32 `protobuf:"varint,14,opt,name=base_decimals,json=baseDecimals,proto3" json:"base_decimals,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,15,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpotMarket) Reset() {
	*x = SpotMarket{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpotMarket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpotMarket) ProtoMessage() {}

func (x *SpotMarket) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpotMarket.ProtoReflect.Descriptor instead.
func (*SpotMarket) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{1}
}

func (x *SpotMarket) GetTicker() string {
	if x != nil {
		return x.Ticker
	}
	return ""
}

func (x *SpotMarket) GetBaseDenom() string {
	if x != nil {
		return x.BaseDenom
	}
	return ""
}

func (x *SpotMarket) GetQuoteDenom() string {
	if x != nil {
		return x.QuoteDenom
	}
	return ""
}

func (x *SpotMarket) GetMakerFeeRate() string {
	if x != nil {
		return x.MakerFeeRate
	}
	return ""
}

func (x *SpotMarket) GetTakerFeeRate() string {
	if x != nil {
		return x.TakerFeeRate
	}
	return ""
}

func (x *SpotMarket) GetRelayerFeeShareRate() string {
	if x != nil {
		return x.RelayerFeeShareRate
	}
	return ""
}

func (x *SpotMarket) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *SpotMarket) GetStatus() MarketStatus {
	if x != nil {
		return x.Status
	}
	return MarketStatus_Unspecified
}

func (x *SpotMarket) GetMinPriceTickSize() string {
	if x != nil {
		return x.MinPriceTickSize
	}
	return ""
}

func (x *SpotMarket) GetMinQuantityTickSize() string {
	if x != nil {
		return x.MinQuantityTickSize
	}
	return ""
}

func (x *SpotMarket) GetMinNotional() string {
	if x != nil {
		return x.MinNotional
	}
	return ""
}

func (x *SpotMarket) GetAdmin() string {
	if x != nil {
		return x.Admin
	}
	return ""
}

func (x *SpotMarket) GetAdminPermissions() uint32 {
	if x != nil {
		return x.AdminPermissions
	}
	return 0
}

func (x *SpotMarket) GetBaseDecimals() uint32 {
	if x != nil {
		return x.BaseDecimals
	}
	return 0
}

func (x *SpotMarket) GetQuoteDecimals() uint32 {
	if x != nil {
		return x.QuoteDecimals
	}
	return 0
}

// An object describing a binary options market in Injective Protocol.
type BinaryOptionsMarket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle symbol
	OracleSymbol string `protobuf:"bytes,2,opt,name=oracle_symbol,json=oracleSymbol,proto3" json:"oracle_symbol,omitempty"`
	// Oracle Provider
	OracleProvider string `protobuf:"bytes,3,opt,name=oracle_provider,json=oracleProvider,proto3" json:"oracle_provider,omitempty"`
	// Oracle type
	OracleType types.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,5,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// expiration timestamp
	ExpirationTimestamp int64 `protobuf:"varint,6,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration timestamp
	SettlementTimestamp int64 `protobuf:"varint,7,opt,name=settlement_timestamp,json=settlementTimestamp,proto3" json:"settlement_timestamp,omitempty"`
	// admin of the market
	Admin string `protobuf:"bytes,8,opt,name=admin,proto3" json:"admin,omitempty"`
	// Address of the quote currency denomination for the binary options contract
	QuoteDenom string `protobuf:"bytes,9,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,10,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// maker_fee_rate defines the maker fee rate of a binary options market
	MakerFeeRate string `protobuf:"bytes,11,opt,name=maker_fee_rate,json=makerFeeRate,proto3" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the taker fee rate of a derivative market
	TakerFeeRate string `protobuf:"bytes,12,opt,name=taker_fee_rate,json=takerFeeRate,proto3" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the percentage of the transaction fee shared
	// with the relayer in a derivative market
	RelayerFeeShareRate string `protobuf:"bytes,13,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3" json:"relayer_fee_share_rate,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,14,opt,name=status,proto3,enum=injective.exchange.v2.MarketStatus" json:"status,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price and margin
	// required for orders in the market (in human readable format)
	MinPriceTickSize string `protobuf:"bytes,15,opt,name=min_price_tick_size,json=minPriceTickSize,proto3" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market (in human readable format)
	MinQuantityTickSize string `protobuf:"bytes,16,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3" json:"min_quantity_tick_size,omitempty"`
	// settlement_price defines the settlement price of the binary options market
	// (in human readable format)
	SettlementPrice string `protobuf:"bytes,17,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlement_price,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market (in human readable format)
	MinNotional string `protobuf:"bytes,18,opt,name=min_notional,json=minNotional,proto3" json:"min_notional,omitempty"`
	// level of admin permissions
	AdminPermissions uint32 `protobuf:"varint,19,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,20,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BinaryOptionsMarket) Reset() {
	*x = BinaryOptionsMarket{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BinaryOptionsMarket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BinaryOptionsMarket) ProtoMessage() {}

func (x *BinaryOptionsMarket) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BinaryOptionsMarket.ProtoReflect.Descriptor instead.
func (*BinaryOptionsMarket) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{2}
}

func (x *BinaryOptionsMarket) GetTicker() string {
	if x != nil {
		return x.Ticker
	}
	return ""
}

func (x *BinaryOptionsMarket) GetOracleSymbol() string {
	if x != nil {
		return x.OracleSymbol
	}
	return ""
}

func (x *BinaryOptionsMarket) GetOracleProvider() string {
	if x != nil {
		return x.OracleProvider
	}
	return ""
}

func (x *BinaryOptionsMarket) GetOracleType() types.OracleType {
	if x != nil {
		return x.OracleType
	}
	return types.OracleType(0)
}

func (x *BinaryOptionsMarket) GetOracleScaleFactor() uint32 {
	if x != nil {
		return x.OracleScaleFactor
	}
	return 0
}

func (x *BinaryOptionsMarket) GetExpirationTimestamp() int64 {
	if x != nil {
		return x.ExpirationTimestamp
	}
	return 0
}

func (x *BinaryOptionsMarket) GetSettlementTimestamp() int64 {
	if x != nil {
		return x.SettlementTimestamp
	}
	return 0
}

func (x *BinaryOptionsMarket) GetAdmin() string {
	if x != nil {
		return x.Admin
	}
	return ""
}

func (x *BinaryOptionsMarket) GetQuoteDenom() string {
	if x != nil {
		return x.QuoteDenom
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMakerFeeRate() string {
	if x != nil {
		return x.MakerFeeRate
	}
	return ""
}

func (x *BinaryOptionsMarket) GetTakerFeeRate() string {
	if x != nil {
		return x.TakerFeeRate
	}
	return ""
}

func (x *BinaryOptionsMarket) GetRelayerFeeShareRate() string {
	if x != nil {
		return x.RelayerFeeShareRate
	}
	return ""
}

func (x *BinaryOptionsMarket) GetStatus() MarketStatus {
	if x != nil {
		return x.Status
	}
	return MarketStatus_Unspecified
}

func (x *BinaryOptionsMarket) GetMinPriceTickSize() string {
	if x != nil {
		return x.MinPriceTickSize
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMinQuantityTickSize() string {
	if x != nil {
		return x.MinQuantityTickSize
	}
	return ""
}

func (x *BinaryOptionsMarket) GetSettlementPrice() string {
	if x != nil {
		return x.SettlementPrice
	}
	return ""
}

func (x *BinaryOptionsMarket) GetMinNotional() string {
	if x != nil {
		return x.MinNotional
	}
	return ""
}

func (x *BinaryOptionsMarket) GetAdminPermissions() uint32 {
	if x != nil {
		return x.AdminPermissions
	}
	return 0
}

func (x *BinaryOptionsMarket) GetQuoteDecimals() uint32 {
	if x != nil {
		return x.QuoteDecimals
	}
	return 0
}

// An object describing a derivative market in the Injective Futures Protocol.
type DerivativeMarket struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ticker for the derivative contract.
	Ticker string `protobuf:"bytes,1,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// Oracle base currency
	OracleBase string `protobuf:"bytes,2,opt,name=oracle_base,json=oracleBase,proto3" json:"oracle_base,omitempty"`
	// Oracle quote currency
	OracleQuote string `protobuf:"bytes,3,opt,name=oracle_quote,json=oracleQuote,proto3" json:"oracle_quote,omitempty"`
	// Oracle type
	OracleType types.OracleType `protobuf:"varint,4,opt,name=oracle_type,json=oracleType,proto3,enum=injective.oracle.v1beta1.OracleType" json:"oracle_type,omitempty"`
	// Scale factor for oracle prices.
	OracleScaleFactor uint32 `protobuf:"varint,5,opt,name=oracle_scale_factor,json=oracleScaleFactor,proto3" json:"oracle_scale_factor,omitempty"`
	// Address of the quote currency denomination for the derivative contract
	QuoteDenom string `protobuf:"bytes,6,opt,name=quote_denom,json=quoteDenom,proto3" json:"quote_denom,omitempty"`
	// Unique market ID.
	MarketId string `protobuf:"bytes,7,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// initial_margin_ratio defines the initial margin ratio of a derivative
	// market
	InitialMarginRatio string `protobuf:"bytes,8,opt,name=initial_margin_ratio,json=initialMarginRatio,proto3" json:"initial_margin_ratio,omitempty"`
	// maintenance_margin_ratio defines the maintenance margin ratio of a
	// derivative market
	MaintenanceMarginRatio string `protobuf:"bytes,9,opt,name=maintenance_margin_ratio,json=maintenanceMarginRatio,proto3" json:"maintenance_margin_ratio,omitempty"`
	// maker_fee_rate defines the maker fee rate of a derivative market
	MakerFeeRate string `protobuf:"bytes,10,opt,name=maker_fee_rate,json=makerFeeRate,proto3" json:"maker_fee_rate,omitempty"`
	// taker_fee_rate defines the taker fee rate of a derivative market
	TakerFeeRate string `protobuf:"bytes,11,opt,name=taker_fee_rate,json=takerFeeRate,proto3" json:"taker_fee_rate,omitempty"`
	// relayer_fee_share_rate defines the percentage of the transaction fee shared
	// with the relayer in a derivative market
	RelayerFeeShareRate string `protobuf:"bytes,12,opt,name=relayer_fee_share_rate,json=relayerFeeShareRate,proto3" json:"relayer_fee_share_rate,omitempty"`
	// true if the market is a perpetual market. false if the market is an expiry
	// futures market
	IsPerpetual bool `protobuf:"varint,13,opt,name=isPerpetual,proto3" json:"isPerpetual,omitempty"`
	// Status of the market
	Status MarketStatus `protobuf:"varint,14,opt,name=status,proto3,enum=injective.exchange.v2.MarketStatus" json:"status,omitempty"`
	// min_price_tick_size defines the minimum tick size that the price and margin
	// required for orders in the market (in human readable format)
	MinPriceTickSize string `protobuf:"bytes,15,opt,name=min_price_tick_size,json=minPriceTickSize,proto3" json:"min_price_tick_size,omitempty"`
	// min_quantity_tick_size defines the minimum tick size of the quantity
	// required for orders in the market (in human readable format)
	MinQuantityTickSize string `protobuf:"bytes,16,opt,name=min_quantity_tick_size,json=minQuantityTickSize,proto3" json:"min_quantity_tick_size,omitempty"`
	// min_notional defines the minimum notional (in quote asset) required for
	// orders in the market (in human readable format)
	MinNotional string `protobuf:"bytes,17,opt,name=min_notional,json=minNotional,proto3" json:"min_notional,omitempty"`
	// current market admin
	Admin string `protobuf:"bytes,18,opt,name=admin,proto3" json:"admin,omitempty"`
	// level of admin permissions
	AdminPermissions uint32 `protobuf:"varint,19,opt,name=admin_permissions,json=adminPermissions,proto3" json:"admin_permissions,omitempty"`
	// quote token decimals
	QuoteDecimals uint32 `protobuf:"varint,20,opt,name=quote_decimals,json=quoteDecimals,proto3" json:"quote_decimals,omitempty"`
	// reduce_margin_ratio defines the ratio of the margin that is reduced
	ReduceMarginRatio string `protobuf:"bytes,21,opt,name=reduce_margin_ratio,json=reduceMarginRatio,proto3" json:"reduce_margin_ratio,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DerivativeMarket) Reset() {
	*x = DerivativeMarket{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeMarket) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeMarket) ProtoMessage() {}

func (x *DerivativeMarket) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeMarket.ProtoReflect.Descriptor instead.
func (*DerivativeMarket) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{3}
}

func (x *DerivativeMarket) GetTicker() string {
	if x != nil {
		return x.Ticker
	}
	return ""
}

func (x *DerivativeMarket) GetOracleBase() string {
	if x != nil {
		return x.OracleBase
	}
	return ""
}

func (x *DerivativeMarket) GetOracleQuote() string {
	if x != nil {
		return x.OracleQuote
	}
	return ""
}

func (x *DerivativeMarket) GetOracleType() types.OracleType {
	if x != nil {
		return x.OracleType
	}
	return types.OracleType(0)
}

func (x *DerivativeMarket) GetOracleScaleFactor() uint32 {
	if x != nil {
		return x.OracleScaleFactor
	}
	return 0
}

func (x *DerivativeMarket) GetQuoteDenom() string {
	if x != nil {
		return x.QuoteDenom
	}
	return ""
}

func (x *DerivativeMarket) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *DerivativeMarket) GetInitialMarginRatio() string {
	if x != nil {
		return x.InitialMarginRatio
	}
	return ""
}

func (x *DerivativeMarket) GetMaintenanceMarginRatio() string {
	if x != nil {
		return x.MaintenanceMarginRatio
	}
	return ""
}

func (x *DerivativeMarket) GetMakerFeeRate() string {
	if x != nil {
		return x.MakerFeeRate
	}
	return ""
}

func (x *DerivativeMarket) GetTakerFeeRate() string {
	if x != nil {
		return x.TakerFeeRate
	}
	return ""
}

func (x *DerivativeMarket) GetRelayerFeeShareRate() string {
	if x != nil {
		return x.RelayerFeeShareRate
	}
	return ""
}

func (x *DerivativeMarket) GetIsPerpetual() bool {
	if x != nil {
		return x.IsPerpetual
	}
	return false
}

func (x *DerivativeMarket) GetStatus() MarketStatus {
	if x != nil {
		return x.Status
	}
	return MarketStatus_Unspecified
}

func (x *DerivativeMarket) GetMinPriceTickSize() string {
	if x != nil {
		return x.MinPriceTickSize
	}
	return ""
}

func (x *DerivativeMarket) GetMinQuantityTickSize() string {
	if x != nil {
		return x.MinQuantityTickSize
	}
	return ""
}

func (x *DerivativeMarket) GetMinNotional() string {
	if x != nil {
		return x.MinNotional
	}
	return ""
}

func (x *DerivativeMarket) GetAdmin() string {
	if x != nil {
		return x.Admin
	}
	return ""
}

func (x *DerivativeMarket) GetAdminPermissions() uint32 {
	if x != nil {
		return x.AdminPermissions
	}
	return 0
}

func (x *DerivativeMarket) GetQuoteDecimals() uint32 {
	if x != nil {
		return x.QuoteDecimals
	}
	return 0
}

func (x *DerivativeMarket) GetReduceMarginRatio() string {
	if x != nil {
		return x.ReduceMarginRatio
	}
	return ""
}

type DerivativeMarketSettlementInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market ID.
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// settlement_price defines the settlement price
	SettlementPrice string `protobuf:"bytes,2,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlement_price,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *DerivativeMarketSettlementInfo) Reset() {
	*x = DerivativeMarketSettlementInfo{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DerivativeMarketSettlementInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DerivativeMarketSettlementInfo) ProtoMessage() {}

func (x *DerivativeMarketSettlementInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DerivativeMarketSettlementInfo.ProtoReflect.Descriptor instead.
func (*DerivativeMarketSettlementInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{4}
}

func (x *DerivativeMarketSettlementInfo) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *DerivativeMarketSettlementInfo) GetSettlementPrice() string {
	if x != nil {
		return x.SettlementPrice
	}
	return ""
}

type MarketVolume struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the market ID
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// the market volume
	Volume        *VolumeRecord `protobuf:"bytes,2,opt,name=volume,proto3" json:"volume,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketVolume) Reset() {
	*x = MarketVolume{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketVolume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketVolume) ProtoMessage() {}

func (x *MarketVolume) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketVolume.ProtoReflect.Descriptor instead.
func (*MarketVolume) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{5}
}

func (x *MarketVolume) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *MarketVolume) GetVolume() *VolumeRecord {
	if x != nil {
		return x.Volume
	}
	return nil
}

type VolumeRecord struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the market's maker volume (in human readable format)
	MakerVolume string `protobuf:"bytes,1,opt,name=maker_volume,json=makerVolume,proto3" json:"maker_volume,omitempty"`
	// the market's taker volume (in human readable format)
	TakerVolume   string `protobuf:"bytes,2,opt,name=taker_volume,json=takerVolume,proto3" json:"taker_volume,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeRecord) Reset() {
	*x = VolumeRecord{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeRecord) ProtoMessage() {}

func (x *VolumeRecord) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeRecord.ProtoReflect.Descriptor instead.
func (*VolumeRecord) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{6}
}

func (x *VolumeRecord) GetMakerVolume() string {
	if x != nil {
		return x.MakerVolume
	}
	return ""
}

func (x *VolumeRecord) GetTakerVolume() string {
	if x != nil {
		return x.TakerVolume
	}
	return ""
}

type ExpiryFuturesMarketInfoState struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	MarketId      string                   `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	MarketInfo    *ExpiryFuturesMarketInfo `protobuf:"bytes,2,opt,name=market_info,json=marketInfo,proto3" json:"market_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExpiryFuturesMarketInfoState) Reset() {
	*x = ExpiryFuturesMarketInfoState{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpiryFuturesMarketInfoState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpiryFuturesMarketInfoState) ProtoMessage() {}

func (x *ExpiryFuturesMarketInfoState) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpiryFuturesMarketInfoState.ProtoReflect.Descriptor instead.
func (*ExpiryFuturesMarketInfoState) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{7}
}

func (x *ExpiryFuturesMarketInfoState) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *ExpiryFuturesMarketInfoState) GetMarketInfo() *ExpiryFuturesMarketInfo {
	if x != nil {
		return x.MarketInfo
	}
	return nil
}

type PerpetualMarketFundingState struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	MarketId      string                  `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	Funding       *PerpetualMarketFunding `protobuf:"bytes,2,opt,name=funding,proto3" json:"funding,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PerpetualMarketFundingState) Reset() {
	*x = PerpetualMarketFundingState{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PerpetualMarketFundingState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PerpetualMarketFundingState) ProtoMessage() {}

func (x *PerpetualMarketFundingState) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PerpetualMarketFundingState.ProtoReflect.Descriptor instead.
func (*PerpetualMarketFundingState) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{8}
}

func (x *PerpetualMarketFundingState) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *PerpetualMarketFundingState) GetFunding() *PerpetualMarketFunding {
	if x != nil {
		return x.Funding
	}
	return nil
}

type ExpiryFuturesMarketInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market ID.
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// expiration_timestamp defines the expiration time for a time expiry futures
	// market.
	ExpirationTimestamp int64 `protobuf:"varint,2,opt,name=expiration_timestamp,json=expirationTimestamp,proto3" json:"expiration_timestamp,omitempty"`
	// expiration_twap_start_timestamp defines the start time of the TWAP
	// calculation window
	TwapStartTimestamp int64 `protobuf:"varint,3,opt,name=twap_start_timestamp,json=twapStartTimestamp,proto3" json:"twap_start_timestamp,omitempty"`
	// expiration_twap_start_price_cumulative defines the cumulative price for the
	// start of the TWAP window (in human readable format)
	ExpirationTwapStartPriceCumulative string `protobuf:"bytes,4,opt,name=expiration_twap_start_price_cumulative,json=expirationTwapStartPriceCumulative,proto3" json:"expiration_twap_start_price_cumulative,omitempty"`
	// settlement_price defines the settlement price for a time expiry futures
	// market (in human readable format)
	SettlementPrice string `protobuf:"bytes,5,opt,name=settlement_price,json=settlementPrice,proto3" json:"settlement_price,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ExpiryFuturesMarketInfo) Reset() {
	*x = ExpiryFuturesMarketInfo{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpiryFuturesMarketInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpiryFuturesMarketInfo) ProtoMessage() {}

func (x *ExpiryFuturesMarketInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpiryFuturesMarketInfo.ProtoReflect.Descriptor instead.
func (*ExpiryFuturesMarketInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{9}
}

func (x *ExpiryFuturesMarketInfo) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *ExpiryFuturesMarketInfo) GetExpirationTimestamp() int64 {
	if x != nil {
		return x.ExpirationTimestamp
	}
	return 0
}

func (x *ExpiryFuturesMarketInfo) GetTwapStartTimestamp() int64 {
	if x != nil {
		return x.TwapStartTimestamp
	}
	return 0
}

func (x *ExpiryFuturesMarketInfo) GetExpirationTwapStartPriceCumulative() string {
	if x != nil {
		return x.ExpirationTwapStartPriceCumulative
	}
	return ""
}

func (x *ExpiryFuturesMarketInfo) GetSettlementPrice() string {
	if x != nil {
		return x.SettlementPrice
	}
	return ""
}

type PerpetualMarketInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// market ID.
	MarketId string `protobuf:"bytes,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// hourly_funding_rate_cap defines the maximum absolute value of the hourly
	// funding rate
	HourlyFundingRateCap string `protobuf:"bytes,2,opt,name=hourly_funding_rate_cap,json=hourlyFundingRateCap,proto3" json:"hourly_funding_rate_cap,omitempty"`
	// hourly_interest_rate defines the hourly interest rate
	HourlyInterestRate string `protobuf:"bytes,3,opt,name=hourly_interest_rate,json=hourlyInterestRate,proto3" json:"hourly_interest_rate,omitempty"`
	// next_funding_timestamp defines the next funding timestamp in seconds of a
	// perpetual market
	NextFundingTimestamp int64 `protobuf:"varint,4,opt,name=next_funding_timestamp,json=nextFundingTimestamp,proto3" json:"next_funding_timestamp,omitempty"`
	// funding_interval defines the next funding interval in seconds of a
	// perpetual market.
	FundingInterval int64 `protobuf:"varint,5,opt,name=funding_interval,json=fundingInterval,proto3" json:"funding_interval,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *PerpetualMarketInfo) Reset() {
	*x = PerpetualMarketInfo{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PerpetualMarketInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PerpetualMarketInfo) ProtoMessage() {}

func (x *PerpetualMarketInfo) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PerpetualMarketInfo.ProtoReflect.Descriptor instead.
func (*PerpetualMarketInfo) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{10}
}

func (x *PerpetualMarketInfo) GetMarketId() string {
	if x != nil {
		return x.MarketId
	}
	return ""
}

func (x *PerpetualMarketInfo) GetHourlyFundingRateCap() string {
	if x != nil {
		return x.HourlyFundingRateCap
	}
	return ""
}

func (x *PerpetualMarketInfo) GetHourlyInterestRate() string {
	if x != nil {
		return x.HourlyInterestRate
	}
	return ""
}

func (x *PerpetualMarketInfo) GetNextFundingTimestamp() int64 {
	if x != nil {
		return x.NextFundingTimestamp
	}
	return 0
}

func (x *PerpetualMarketInfo) GetFundingInterval() int64 {
	if x != nil {
		return x.FundingInterval
	}
	return 0
}

type PerpetualMarketFunding struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cumulative_funding defines the cumulative funding of a perpetual market.
	CumulativeFunding string `protobuf:"bytes,1,opt,name=cumulative_funding,json=cumulativeFunding,proto3" json:"cumulative_funding,omitempty"`
	// cumulative_price defines the running time-integral of the perp premium
	// ((VWAP - mark_price) / mark_price) i.e., sum(premium * seconds)
	// used to compute the interval’s average premium for funding
	CumulativePrice string `protobuf:"bytes,2,opt,name=cumulative_price,json=cumulativePrice,proto3" json:"cumulative_price,omitempty"`
	// the last funding timestamp in seconds
	LastTimestamp int64 `protobuf:"varint,3,opt,name=last_timestamp,json=lastTimestamp,proto3" json:"last_timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PerpetualMarketFunding) Reset() {
	*x = PerpetualMarketFunding{}
	mi := &file_injective_exchange_v2_market_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PerpetualMarketFunding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PerpetualMarketFunding) ProtoMessage() {}

func (x *PerpetualMarketFunding) ProtoReflect() protoreflect.Message {
	mi := &file_injective_exchange_v2_market_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PerpetualMarketFunding.ProtoReflect.Descriptor instead.
func (*PerpetualMarketFunding) Descriptor() ([]byte, []int) {
	return file_injective_exchange_v2_market_proto_rawDescGZIP(), []int{11}
}

func (x *PerpetualMarketFunding) GetCumulativeFunding() string {
	if x != nil {
		return x.CumulativeFunding
	}
	return ""
}

func (x *PerpetualMarketFunding) GetCumulativePrice() string {
	if x != nil {
		return x.CumulativePrice
	}
	return ""
}

func (x *PerpetualMarketFunding) GetLastTimestamp() int64 {
	if x != nil {
		return x.LastTimestamp
	}
	return 0
}

var File_injective_exchange_v2_market_proto protoreflect.FileDescriptor

const file_injective_exchange_v2_market_proto_rawDesc = "" +
	"\n" +
	"\"injective/exchange/v2/market.proto\x12\x15injective.exchange.v2\x1a\x14gogoproto/gogo.proto\x1a%injective/oracle/v1beta1/oracle.proto\"\x84\x01\n" +
	"\x13MarketFeeMultiplier\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12J\n" +
	"\x0efee_multiplier\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\rfeeMultiplier:\x04\x88\xa0\x1f\x00\"\xb3\x06\n" +
	"\n" +
	"SpotMarket\x12\x16\n" +
	"\x06ticker\x18\x01 \x01(\tR\x06ticker\x12\x1d\n" +
	"\n" +
	"base_denom\x18\x02 \x01(\tR\tbaseDenom\x12\x1f\n" +
	"\vquote_denom\x18\x03 \x01(\tR\n" +
	"quoteDenom\x12I\n" +
	"\x0emaker_fee_rate\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\fmakerFeeRate\x12I\n" +
	"\x0etaker_fee_rate\x18\x05 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftakerFeeRate\x12X\n" +
	"\x16relayer_fee_share_rate\x18\x06 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13relayerFeeShareRate\x12\x1b\n" +
	"\tmarket_id\x18\a \x01(\tR\bmarketId\x12;\n" +
	"\x06status\x18\b \x01(\x0e2#.injective.exchange.v2.MarketStatusR\x06status\x12R\n" +
	"\x13min_price_tick_size\x18\t \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x10minPriceTickSize\x12X\n" +
	"\x16min_quantity_tick_size\x18\n" +
	" \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13minQuantityTickSize\x12F\n" +
	"\fmin_notional\x18\v \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vminNotional\x12\x14\n" +
	"\x05admin\x18\f \x01(\tR\x05admin\x12+\n" +
	"\x11admin_permissions\x18\r \x01(\rR\x10adminPermissions\x12#\n" +
	"\rbase_decimals\x18\x0e \x01(\rR\fbaseDecimals\x12%\n" +
	"\x0equote_decimals\x18\x0f \x01(\rR\rquoteDecimals\"\xf9\b\n" +
	"\x13BinaryOptionsMarket\x12\x16\n" +
	"\x06ticker\x18\x01 \x01(\tR\x06ticker\x12#\n" +
	"\roracle_symbol\x18\x02 \x01(\tR\foracleSymbol\x12'\n" +
	"\x0foracle_provider\x18\x03 \x01(\tR\x0eoracleProvider\x12E\n" +
	"\voracle_type\x18\x04 \x01(\x0e2$.injective.oracle.v1beta1.OracleTypeR\n" +
	"oracleType\x12.\n" +
	"\x13oracle_scale_factor\x18\x05 \x01(\rR\x11oracleScaleFactor\x121\n" +
	"\x14expiration_timestamp\x18\x06 \x01(\x03R\x13expirationTimestamp\x121\n" +
	"\x14settlement_timestamp\x18\a \x01(\x03R\x13settlementTimestamp\x12\x14\n" +
	"\x05admin\x18\b \x01(\tR\x05admin\x12\x1f\n" +
	"\vquote_denom\x18\t \x01(\tR\n" +
	"quoteDenom\x12\x1b\n" +
	"\tmarket_id\x18\n" +
	" \x01(\tR\bmarketId\x12I\n" +
	"\x0emaker_fee_rate\x18\v \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\fmakerFeeRate\x12I\n" +
	"\x0etaker_fee_rate\x18\f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftakerFeeRate\x12X\n" +
	"\x16relayer_fee_share_rate\x18\r \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13relayerFeeShareRate\x12;\n" +
	"\x06status\x18\x0e \x01(\x0e2#.injective.exchange.v2.MarketStatusR\x06status\x12R\n" +
	"\x13min_price_tick_size\x18\x0f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x10minPriceTickSize\x12X\n" +
	"\x16min_quantity_tick_size\x18\x10 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13minQuantityTickSize\x12N\n" +
	"\x10settlement_price\x18\x11 \x01(\tB#\xc8\xde\x1f\x01\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fsettlementPrice\x12F\n" +
	"\fmin_notional\x18\x12 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vminNotional\x12+\n" +
	"\x11admin_permissions\x18\x13 \x01(\rR\x10adminPermissions\x12%\n" +
	"\x0equote_decimals\x18\x14 \x01(\rR\rquoteDecimals:\x04\x88\xa0\x1f\x00\"\xe3\t\n" +
	"\x10DerivativeMarket\x12\x16\n" +
	"\x06ticker\x18\x01 \x01(\tR\x06ticker\x12\x1f\n" +
	"\voracle_base\x18\x02 \x01(\tR\n" +
	"oracleBase\x12!\n" +
	"\foracle_quote\x18\x03 \x01(\tR\voracleQuote\x12E\n" +
	"\voracle_type\x18\x04 \x01(\x0e2$.injective.oracle.v1beta1.OracleTypeR\n" +
	"oracleType\x12.\n" +
	"\x13oracle_scale_factor\x18\x05 \x01(\rR\x11oracleScaleFactor\x12\x1f\n" +
	"\vquote_denom\x18\x06 \x01(\tR\n" +
	"quoteDenom\x12\x1b\n" +
	"\tmarket_id\x18\a \x01(\tR\bmarketId\x12U\n" +
	"\x14initial_margin_ratio\x18\b \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x12initialMarginRatio\x12]\n" +
	"\x18maintenance_margin_ratio\x18\t \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x16maintenanceMarginRatio\x12I\n" +
	"\x0emaker_fee_rate\x18\n" +
	" \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\fmakerFeeRate\x12I\n" +
	"\x0etaker_fee_rate\x18\v \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\ftakerFeeRate\x12X\n" +
	"\x16relayer_fee_share_rate\x18\f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13relayerFeeShareRate\x12 \n" +
	"\visPerpetual\x18\r \x01(\bR\visPerpetual\x12;\n" +
	"\x06status\x18\x0e \x01(\x0e2#.injective.exchange.v2.MarketStatusR\x06status\x12R\n" +
	"\x13min_price_tick_size\x18\x0f \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x10minPriceTickSize\x12X\n" +
	"\x16min_quantity_tick_size\x18\x10 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x13minQuantityTickSize\x12F\n" +
	"\fmin_notional\x18\x11 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vminNotional\x12\x14\n" +
	"\x05admin\x18\x12 \x01(\tR\x05admin\x12+\n" +
	"\x11admin_permissions\x18\x13 \x01(\rR\x10adminPermissions\x12%\n" +
	"\x0equote_decimals\x18\x14 \x01(\rR\rquoteDecimals\x12S\n" +
	"\x13reduce_margin_ratio\x18\x15 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x11reduceMarginRatio:\x04\x88\xa0\x1f\x00\"\x8d\x01\n" +
	"\x1eDerivativeMarketSettlementInfo\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12N\n" +
	"\x10settlement_price\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fsettlementPrice\"n\n" +
	"\fMarketVolume\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12A\n" +
	"\x06volume\x18\x02 \x01(\v2#.injective.exchange.v2.VolumeRecordB\x04\xc8\xde\x1f\x00R\x06volume\"\x9e\x01\n" +
	"\fVolumeRecord\x12F\n" +
	"\fmaker_volume\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vmakerVolume\x12F\n" +
	"\ftaker_volume\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\vtakerVolume\"\x8c\x01\n" +
	"\x1cExpiryFuturesMarketInfoState\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12O\n" +
	"\vmarket_info\x18\x02 \x01(\v2..injective.exchange.v2.ExpiryFuturesMarketInfoR\n" +
	"marketInfo\"\x83\x01\n" +
	"\x1bPerpetualMarketFundingState\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12G\n" +
	"\afunding\x18\x02 \x01(\v2-.injective.exchange.v2.PerpetualMarketFundingR\afunding\"\xe4\x02\n" +
	"\x17ExpiryFuturesMarketInfo\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x121\n" +
	"\x14expiration_timestamp\x18\x02 \x01(\x03R\x13expirationTimestamp\x120\n" +
	"\x14twap_start_timestamp\x18\x03 \x01(\x03R\x12twapStartTimestamp\x12w\n" +
	"&expiration_twap_start_price_cumulative\x18\x04 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\"expirationTwapStartPriceCumulative\x12N\n" +
	"\x10settlement_price\x18\x05 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fsettlementPrice\"\xc6\x02\n" +
	"\x13PerpetualMarketInfo\x12\x1b\n" +
	"\tmarket_id\x18\x01 \x01(\tR\bmarketId\x12Z\n" +
	"\x17hourly_funding_rate_cap\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x14hourlyFundingRateCap\x12U\n" +
	"\x14hourly_interest_rate\x18\x03 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x12hourlyInterestRate\x124\n" +
	"\x16next_funding_timestamp\x18\x04 \x01(\x03R\x14nextFundingTimestamp\x12)\n" +
	"\x10funding_interval\x18\x05 \x01(\x03R\x0ffundingInterval\"\xe3\x01\n" +
	"\x16PerpetualMarketFunding\x12R\n" +
	"\x12cumulative_funding\x18\x01 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x11cumulativeFunding\x12N\n" +
	"\x10cumulative_price\x18\x02 \x01(\tB#\xc8\xde\x1f\x00\xda\xde\x1f\x1bcosmossdk.io/math.LegacyDecR\x0fcumulativePrice\x12%\n" +
	"\x0elast_timestamp\x18\x03 \x01(\x03R\rlastTimestamp*T\n" +
	"\fMarketStatus\x12\x0f\n" +
	"\vUnspecified\x10\x00\x12\n" +
	"\n" +
	"\x06Active\x10\x01\x12\n" +
	"\n" +
	"\x06Paused\x10\x02\x12\x0e\n" +
	"\n" +
	"Demolished\x10\x03\x12\v\n" +
	"\aExpired\x10\x04BSZQgithub.com/InjectiveLabs/injective-core/injective-chain/modules/exchange/types/v2b\x06proto3"

var (
	file_injective_exchange_v2_market_proto_rawDescOnce sync.Once
	file_injective_exchange_v2_market_proto_rawDescData []byte
)

func file_injective_exchange_v2_market_proto_rawDescGZIP() []byte {
	file_injective_exchange_v2_market_proto_rawDescOnce.Do(func() {
		file_injective_exchange_v2_market_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_injective_exchange_v2_market_proto_rawDesc), len(file_injective_exchange_v2_market_proto_rawDesc)))
	})
	return file_injective_exchange_v2_market_proto_rawDescData
}

var file_injective_exchange_v2_market_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_injective_exchange_v2_market_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_injective_exchange_v2_market_proto_goTypes = []any{
	(MarketStatus)(0),                      // 0: injective.exchange.v2.MarketStatus
	(*MarketFeeMultiplier)(nil),            // 1: injective.exchange.v2.MarketFeeMultiplier
	(*SpotMarket)(nil),                     // 2: injective.exchange.v2.SpotMarket
	(*BinaryOptionsMarket)(nil),            // 3: injective.exchange.v2.BinaryOptionsMarket
	(*DerivativeMarket)(nil),               // 4: injective.exchange.v2.DerivativeMarket
	(*DerivativeMarketSettlementInfo)(nil), // 5: injective.exchange.v2.DerivativeMarketSettlementInfo
	(*MarketVolume)(nil),                   // 6: injective.exchange.v2.MarketVolume
	(*VolumeRecord)(nil),                   // 7: injective.exchange.v2.VolumeRecord
	(*ExpiryFuturesMarketInfoState)(nil),   // 8: injective.exchange.v2.ExpiryFuturesMarketInfoState
	(*PerpetualMarketFundingState)(nil),    // 9: injective.exchange.v2.PerpetualMarketFundingState
	(*ExpiryFuturesMarketInfo)(nil),        // 10: injective.exchange.v2.ExpiryFuturesMarketInfo
	(*PerpetualMarketInfo)(nil),            // 11: injective.exchange.v2.PerpetualMarketInfo
	(*PerpetualMarketFunding)(nil),         // 12: injective.exchange.v2.PerpetualMarketFunding
	(types.OracleType)(0),                  // 13: injective.oracle.v1beta1.OracleType
}
var file_injective_exchange_v2_market_proto_depIdxs = []int32{
	0,  // 0: injective.exchange.v2.SpotMarket.status:type_name -> injective.exchange.v2.MarketStatus
	13, // 1: injective.exchange.v2.BinaryOptionsMarket.oracle_type:type_name -> injective.oracle.v1beta1.OracleType
	0,  // 2: injective.exchange.v2.BinaryOptionsMarket.status:type_name -> injective.exchange.v2.MarketStatus
	13, // 3: injective.exchange.v2.DerivativeMarket.oracle_type:type_name -> injective.oracle.v1beta1.OracleType
	0,  // 4: injective.exchange.v2.DerivativeMarket.status:type_name -> injective.exchange.v2.MarketStatus
	7,  // 5: injective.exchange.v2.MarketVolume.volume:type_name -> injective.exchange.v2.VolumeRecord
	10, // 6: injective.exchange.v2.ExpiryFuturesMarketInfoState.market_info:type_name -> injective.exchange.v2.ExpiryFuturesMarketInfo
	12, // 7: injective.exchange.v2.PerpetualMarketFundingState.funding:type_name -> injective.exchange.v2.PerpetualMarketFunding
	8,  // [8:8] is the sub-list for method output_type
	8,  // [8:8] is the sub-list for method input_type
	8,  // [8:8] is the sub-list for extension type_name
	8,  // [8:8] is the sub-list for extension extendee
	0,  // [0:8] is the sub-list for field type_name
}

func init() { file_injective_exchange_v2_market_proto_init() }
func file_injective_exchange_v2_market_proto_init() {
	if File_injective_exchange_v2_market_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_injective_exchange_v2_market_proto_rawDesc), len(file_injective_exchange_v2_market_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_injective_exchange_v2_market_proto_goTypes,
		DependencyIndexes: file_injective_exchange_v2_market_proto_depIdxs,
		EnumInfos:         file_injective_exchange_v2_market_proto_enumTypes,
		MessageInfos:      file_injective_exchange_v2_market_proto_msgTypes,
	}.Build()
	File_injective_exchange_v2_market_proto = out.File
	file_injective_exchange_v2_market_proto_goTypes = nil
	file_injective_exchange_v2_market_proto_depIdxs = nil
}
